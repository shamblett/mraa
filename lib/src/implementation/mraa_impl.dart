//  mraa package
//  Author: S.Hamblett <steve.hamblett@linux.com>
//  Copyright © 2022 S. Hamblett
//
//  MRAA library API C files
//  Author: Brendan Le Foll <brendan.le.foll@intel.com>
//  Copyright © 2014 Intel Corporation
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// ignore_for_file: camel_case_types, non_constant_identifier_names, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Holds ffigen generated implementation bindings to MRAA.
class MraaImpl {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  MraaImpl(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  MraaImpl.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  int mraa_init() {
    return _mraa_init();
  }

  late final _mraa_initPtr = _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
    'mraa_init',
  );
  late final _mraa_init = _mraa_initPtr.asFunction<int Function()>();

  /// De-Initilise MRAA
  ///
  /// This is not a strict requirement but useful to test memory leaks and for
  /// people who like super clean code. If dynamically loading & unloading
  /// libmraa you need to call this before unloading the library.
  void mraa_deinit() {
    return _mraa_deinit();
  }

  late final _mraa_deinitPtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>(
    'mraa_deinit',
  );
  late final _mraa_deinit = _mraa_deinitPtr.asFunction<void Function()>();

  /// Checks if a pin is able to use the passed in mode.
  ///
  /// @param pin Physical Pin to be checked.
  /// @param mode the mode to be tested.
  /// @return boolean if the mode is supported, 0=false.
  int mraa_pin_mode_test(int pin, int mode) {
    return _mraa_pin_mode_test(pin, mode);
  }

  late final _mraa_pin_mode_testPtr =
      _lookup<ffi.NativeFunction<mraa_boolean_t Function(ffi.Int, ffi.Int32)>>(
        'mraa_pin_mode_test',
      );
  late final _mraa_pin_mode_test =
      _mraa_pin_mode_testPtr.asFunction<int Function(int, int)>();

  /// Check the board's  bit size when reading the value
  ///
  /// @return raw bits being read from kernel module. zero if no ADC
  int mraa_adc_raw_bits() {
    return _mraa_adc_raw_bits();
  }

  late final _mraa_adc_raw_bitsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
        'mraa_adc_raw_bits',
      );
  late final _mraa_adc_raw_bits =
      _mraa_adc_raw_bitsPtr.asFunction<int Function()>();

  /// Check the specified board's bit size when reading the value
  ///
  /// @param platform_offset specified platform offset; 0 for main platform, 1 for sub platform
  /// @return raw bits being read from kernel module. zero if no ADC
  int mraa_get_platform_adc_raw_bits(int platform_offset) {
    return _mraa_get_platform_adc_raw_bits(platform_offset);
  }

  late final _mraa_get_platform_adc_raw_bitsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Uint8)>>(
        'mraa_get_platform_adc_raw_bits',
      );
  late final _mraa_get_platform_adc_raw_bits =
      _mraa_get_platform_adc_raw_bitsPtr.asFunction<int Function(int)>();

  /// Return value that the raw value should be shifted to. Zero if no ADC
  ///
  /// @return return actual bit size the adc value should be understood as.
  int mraa_adc_supported_bits() {
    return _mraa_adc_supported_bits();
  }

  late final _mraa_adc_supported_bitsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
        'mraa_adc_supported_bits',
      );
  late final _mraa_adc_supported_bits =
      _mraa_adc_supported_bitsPtr.asFunction<int Function()>();

  /// Return value that the raw value should be shifted to. Zero if no ADC
  ///
  /// @param platform_offset specified platform offset; 0 for main platform, 1 for sub platform
  /// @return return actual bit size the adc value should be understood as.
  int mraa_get_platform_adc_supported_bits(int platform_offset) {
    return _mraa_get_platform_adc_supported_bits(platform_offset);
  }

  late final _mraa_get_platform_adc_supported_bitsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int)>>(
        'mraa_get_platform_adc_supported_bits',
      );
  late final _mraa_get_platform_adc_supported_bits =
      _mraa_get_platform_adc_supported_bitsPtr.asFunction<int Function(int)>();

  /// Sets the log level to use from 0-7 where 7 is very verbose. These are the
  /// syslog log levels, see syslog(3) for more information on the levels.
  ///
  /// @return Result of operation
  int mraa_set_log_level(int level) {
    return _mraa_set_log_level(level);
  }

  late final _mraa_set_log_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int)>>(
        'mraa_set_log_level',
      );
  late final _mraa_set_log_level =
      _mraa_set_log_levelPtr.asFunction<int Function(int)>();

  /// Return the Platform's Name, If no platform detected return NULL
  ///
  /// @return platform name
  ffi.Pointer<ffi.Char> mraa_get_platform_name() {
    return _mraa_get_platform_name();
  }

  late final _mraa_get_platform_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'mraa_get_platform_name',
      );
  late final _mraa_get_platform_name =
      _mraa_get_platform_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the platform's versioning info, the information given depends per
  /// platform and can be NULL. platform_offset has to be given. Do not modify
  /// this pointer
  ///
  /// @param platform_offset specified platform offset; 0 for main platform, 1 for sub platform
  /// @return platform's versioning string
  ffi.Pointer<ffi.Char> mraa_get_platform_version(int platform_offset) {
    return _mraa_get_platform_version(platform_offset);
  }

  late final _mraa_get_platform_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
        'mraa_get_platform_version',
      );
  late final _mraa_get_platform_version =
      _mraa_get_platform_versionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// This function attempts to set the mraa process to a given priority and the
  /// scheduler to SCHED_RR. Highest * priority is typically 99 and minimum is 0.
  /// This function * will set to MAX if * priority is > MAX. Function will return
  /// -1 on failure.
  ///
  /// @param priority Value from typically 0 to 99
  /// @return The priority value set
  int mraa_set_priority(int priority) {
    return _mraa_set_priority(priority);
  }

  late final _mraa_set_priorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
        'mraa_set_priority',
      );
  late final _mraa_set_priority =
      _mraa_set_priorityPtr.asFunction<int Function(int)>();

  /// Get the version string of mraa autogenerated from git tag
  ///
  /// The version returned may not be what is expected however it is a reliable
  /// number associated with the git tag closest to that version at build time
  ///
  /// @return version string from version.h
  ffi.Pointer<ffi.Char> mraa_get_version() {
    return _mraa_get_version();
  }

  late final _mraa_get_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'mraa_get_version',
      );
  late final _mraa_get_version =
      _mraa_get_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Returns a textual representation of the mraa_result_t
  ///
  /// @param result the result to stringify
  ffi.Pointer<ffi.Char> mraa_strresult(int result) {
    return _mraa_strresult(result);
  }

  late final _mraa_strresultPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
        'mraa_strresult',
      );
  late final _mraa_strresult =
      _mraa_strresultPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Print a textual representation of the mraa_result_t
  ///
  /// @param result the result to print
  void mraa_result_print(int result) {
    return _mraa_result_print(result);
  }

  late final _mraa_result_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
        'mraa_result_print',
      );
  late final _mraa_result_print =
      _mraa_result_printPtr.asFunction<void Function(int)>();

  /// Get platform type, board must be initialised.
  ///
  /// @return mraa_platform_t Platform type enum
  int mraa_get_platform_type() {
    return _mraa_get_platform_type();
  }

  late final _mraa_get_platform_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
        'mraa_get_platform_type',
      );
  late final _mraa_get_platform_type =
      _mraa_get_platform_typePtr.asFunction<int Function()>();

  /// Get combined platform type, board must be initialised.
  /// The combined type is represented as
  /// (sub_platform_type << 8) | main_platform_type
  ///
  /// @return int combined platform type
  int mraa_get_platform_combined_type() {
    return _mraa_get_platform_combined_type();
  }

  late final _mraa_get_platform_combined_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
        'mraa_get_platform_combined_type',
      );
  late final _mraa_get_platform_combined_type =
      _mraa_get_platform_combined_typePtr.asFunction<int Function()>();

  /// Get platform pincount, board must be initialised.
  ///
  /// @return uint of physical pin count on the in-use platform
  int mraa_get_pin_count() {
    return _mraa_get_pin_count();
  }

  late final _mraa_get_pin_countPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
        'mraa_get_pin_count',
      );
  late final _mraa_get_pin_count =
      _mraa_get_pin_countPtr.asFunction<int Function()>();

  /// Get the number of usable UARTs, board must be initialised.
  ///
  /// @return number of usable UARTs on the platform, returns -1 on failure.
  int mraa_get_uart_count() {
    return _mraa_get_uart_count();
  }

  late final _mraa_get_uart_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('mraa_get_uart_count');
  late final _mraa_get_uart_count =
      _mraa_get_uart_countPtr.asFunction<int Function()>();

  /// Get the number of usable SPI buses, board must be initialised.
  ///
  /// @return number of usable SPI buses on the platform, returns -1 on failure.
  int mraa_get_spi_bus_count() {
    return _mraa_get_spi_bus_count();
  }

  late final _mraa_get_spi_bus_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('mraa_get_spi_bus_count');
  late final _mraa_get_spi_bus_count =
      _mraa_get_spi_bus_countPtr.asFunction<int Function()>();

  /// Get the number of usable PWM pins, board must be initialised.
  ///
  /// @return number of PWMs on the current platform, -1 on failure.
  int mraa_get_pwm_count() {
    return _mraa_get_pwm_count();
  }

  late final _mraa_get_pwm_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('mraa_get_pwm_count');
  late final _mraa_get_pwm_count =
      _mraa_get_pwm_countPtr.asFunction<int Function()>();

  /// Get the number of usable GPIOs, board must be initialised.
  ///
  /// @return number of usable external GPIO pins on the board, -1 on failure.
  int mraa_get_gpio_count() {
    return _mraa_get_gpio_count();
  }

  late final _mraa_get_gpio_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('mraa_get_gpio_count');
  late final _mraa_get_gpio_count =
      _mraa_get_gpio_countPtr.asFunction<int Function()>();

  /// Get the number of usable analog pins, board must be initialised.
  ///
  /// @return number of usable ADC inputs on the platform and -1 on failure.
  int mraa_get_aio_count() {
    return _mraa_get_aio_count();
  }

  late final _mraa_get_aio_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('mraa_get_aio_count');
  late final _mraa_get_aio_count =
      _mraa_get_aio_countPtr.asFunction<int Function()>();

  /// Get platform usable I2C bus count, board must be initialised.
  ///
  /// @return number f usable I2C bus count on the current platform. Function will
  /// return -1 on failure
  int mraa_get_i2c_bus_count() {
    return _mraa_get_i2c_bus_count();
  }

  late final _mraa_get_i2c_bus_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('mraa_get_i2c_bus_count');
  late final _mraa_get_i2c_bus_count =
      _mraa_get_i2c_bus_countPtr.asFunction<int Function()>();

  /// Get I2C adapter number in sysfs.
  ///
  /// @param i2c_bus the logical I2C bus number
  /// @return I2C adapter number in sysfs. Function will return -1 on failure
  int mraa_get_i2c_bus_id(int i2c_bus) {
    return _mraa_get_i2c_bus_id(i2c_bus);
  }

  late final _mraa_get_i2c_bus_idPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
        'mraa_get_i2c_bus_id',
      );
  late final _mraa_get_i2c_bus_id =
      _mraa_get_i2c_bus_idPtr.asFunction<int Function(int)>();

  /// Get specified platform pincount, board must be initialised.
  ///
  /// @param platform_offset specified platform offset; 0 for main platform, 1 for sub platform
  /// @return uint of physical pin count on the in-use platform
  int mraa_get_platform_pin_count(int platform_offset) {
    return _mraa_get_platform_pin_count(platform_offset);
  }

  late final _mraa_get_platform_pin_countPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Uint8)>>(
        'mraa_get_platform_pin_count',
      );
  late final _mraa_get_platform_pin_count =
      _mraa_get_platform_pin_countPtr.asFunction<int Function(int)>();

  /// Get name of pin, board must be initialised.
  ///
  /// @param pin number
  /// @return char* of pin name
  ffi.Pointer<ffi.Char> mraa_get_pin_name(int pin) {
    return _mraa_get_pin_name(pin);
  }

  late final _mraa_get_pin_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
        'mraa_get_pin_name',
      );
  late final _mraa_get_pin_name =
      _mraa_get_pin_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get GPIO index by pin name, board must be initialised.
  ///
  /// @param pin_name: GPIO pin name. Eg: IO0
  /// @return int of MRAA index for GPIO or -1 if not found.
  int mraa_gpio_lookup(ffi.Pointer<ffi.Char> pin_name) {
    return _mraa_gpio_lookup(pin_name);
  }

  late final _mraa_gpio_lookupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'mraa_gpio_lookup',
      );
  late final _mraa_gpio_lookup =
      _mraa_gpio_lookupPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get I2C bus index by bus name, board must be initialised.
  ///
  /// @param i2c_name: I2C bus name. Eg: I2C6
  /// @return int of MRAA index for I2C bus or -1 if not found.
  int mraa_i2c_lookup(ffi.Pointer<ffi.Char> i2c_name) {
    return _mraa_i2c_lookup(i2c_name);
  }

  late final _mraa_i2c_lookupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'mraa_i2c_lookup',
      );
  late final _mraa_i2c_lookup =
      _mraa_i2c_lookupPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get SPI bus index by bus name, board must be initialised.
  ///
  /// @param spi_name: Name of SPI bus. Eg: SPI2
  /// @return int of MRAA index for SPI bus or -1 if not found.
  int mraa_spi_lookup(ffi.Pointer<ffi.Char> spi_name) {
    return _mraa_spi_lookup(spi_name);
  }

  late final _mraa_spi_lookupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'mraa_spi_lookup',
      );
  late final _mraa_spi_lookup =
      _mraa_spi_lookupPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get PWM index by PWM name, board must be initialised.
  ///
  /// @param pwm_name: Name of PWM. Eg:PWM0
  /// @return int of MRAA index for PWM or -1 if not found.
  int mraa_pwm_lookup(ffi.Pointer<ffi.Char> pwm_name) {
    return _mraa_pwm_lookup(pwm_name);
  }

  late final _mraa_pwm_lookupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'mraa_pwm_lookup',
      );
  late final _mraa_pwm_lookup =
      _mraa_pwm_lookupPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get UART index by name, board must be initialised.
  ///
  /// @param uart_name: Name of UART. Eg:UART1
  /// @return int of MRAA index for UART, or -1 if not found.
  int mraa_uart_lookup(ffi.Pointer<ffi.Char> uart_name) {
    return _mraa_uart_lookup(uart_name);
  }

  late final _mraa_uart_lookupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'mraa_uart_lookup',
      );
  late final _mraa_uart_lookup =
      _mraa_uart_lookupPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get default i2c bus, board must be initialised.
  ///
  /// @return int default i2c bus index
  int mraa_get_default_i2c_bus(int platform_offset) {
    return _mraa_get_default_i2c_bus(platform_offset);
  }

  late final _mraa_get_default_i2c_busPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint8)>>(
        'mraa_get_default_i2c_bus',
      );
  late final _mraa_get_default_i2c_bus =
      _mraa_get_default_i2c_busPtr.asFunction<int Function(int)>();

  /// Detect presence of sub platform.
  ///
  /// @return mraa_boolean_t 1 if sub platform is present and initialized, 0 otherwise
  int mraa_has_sub_platform() {
    return _mraa_has_sub_platform();
  }

  late final _mraa_has_sub_platformPtr =
      _lookup<ffi.NativeFunction<mraa_boolean_t Function()>>(
        'mraa_has_sub_platform',
      );
  late final _mraa_has_sub_platform =
      _mraa_has_sub_platformPtr.asFunction<int Function()>();

  /// Check if pin or bus id includes sub platform mask.
  ///
  /// @param pin_or_bus_id pin or bus number
  ///
  /// @return mraa_boolean_t 1 if pin or bus is for sub platform, 0 otherwise
  int mraa_is_sub_platform_id(int pin_or_bus_id) {
    return _mraa_is_sub_platform_id(pin_or_bus_id);
  }

  late final _mraa_is_sub_platform_idPtr =
      _lookup<ffi.NativeFunction<mraa_boolean_t Function(ffi.Int)>>(
        'mraa_is_sub_platform_id',
      );
  late final _mraa_is_sub_platform_id =
      _mraa_is_sub_platform_idPtr.asFunction<int Function(int)>();

  /// Convert pin or bus index to corresponding sub platform id.
  ///
  /// @param pin_or_bus_index pin or bus index
  ///
  /// @return int sub platform pin or bus number
  int mraa_get_sub_platform_id(int pin_or_bus_index) {
    return _mraa_get_sub_platform_id(pin_or_bus_index);
  }

  late final _mraa_get_sub_platform_idPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
        'mraa_get_sub_platform_id',
      );
  late final _mraa_get_sub_platform_id =
      _mraa_get_sub_platform_idPtr.asFunction<int Function(int)>();

  /// Convert pin or bus sub platform id to index.
  ///
  /// @param pin_or_bus_id sub platform pin or bus id
  ///
  /// @return int pin or bus index
  int mraa_get_sub_platform_index(int pin_or_bus_id) {
    return _mraa_get_sub_platform_index(pin_or_bus_id);
  }

  late final _mraa_get_sub_platform_indexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
        'mraa_get_sub_platform_index',
      );
  late final _mraa_get_sub_platform_index =
      _mraa_get_sub_platform_indexPtr.asFunction<int Function(int)>();

  /// Add mraa subplatform
  ///
  /// @param subplatformtype subplatform type
  /// @param dev uart device or i2c bus subplatform is on
  ///
  /// @return mraa_result_t indicating success
  int mraa_add_subplatform(int subplatformtype, ffi.Pointer<ffi.Char> dev) {
    return _mraa_add_subplatform(subplatformtype, dev);
  }

  late final _mraa_add_subplatformPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Char>)>
  >('mraa_add_subplatform');
  late final _mraa_add_subplatform =
      _mraa_add_subplatformPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Remove a mraa subplatform
  ///
  /// @param subplatformtype subplatform type
  ///
  /// @return mraa_result indicating success
  int mraa_remove_subplatform(int subplatformtype) {
    return _mraa_remove_subplatform(subplatformtype);
  }

  late final _mraa_remove_subplatformPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
        'mraa_remove_subplatform',
      );
  late final _mraa_remove_subplatform =
      _mraa_remove_subplatformPtr.asFunction<int Function(int)>();

  /// Create IO using a description in the format:
  /// [io]-[pin]
  /// [io]-[raw]-[pin]
  /// [io]-[raw]-[id]-[pin]
  /// [io]-[raw]-[path]
  ///
  /// @param desc IO description
  ///
  /// @return void* to IO context or NULL
  ffi.Pointer<ffi.Void> mraa_init_io(ffi.Pointer<ffi.Char> desc) {
    return _mraa_init_io(desc);
  }

  late final _mraa_init_ioPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>
  >('mraa_init_io');
  late final _mraa_init_io =
      _mraa_init_ioPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// Instantiate an unknown board using a json file
  ///
  /// @param path Path to the json file, relative to the folder the program
  /// was initially run in or a direct path
  ///
  /// @return mraa_result indicating success
  int mraa_init_json_platform(ffi.Pointer<ffi.Char> path) {
    return _mraa_init_json_platform(path);
  }

  late final _mraa_init_json_platformPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
        'mraa_init_json_platform',
      );
  late final _mraa_init_json_platform =
      _mraa_init_json_platformPtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Initialise pwm_context, uses board mapping
  ///
  /// @param pin The PWM PIN
  /// @return pwm context or NULL
  mraa_pwm_context mraa_pwm_init(int pin) {
    return _mraa_pwm_init(pin);
  }

  late final _mraa_pwm_initPtr =
      _lookup<ffi.NativeFunction<mraa_pwm_context Function(ffi.Int)>>(
        'mraa_pwm_init',
      );
  late final _mraa_pwm_init =
      _mraa_pwm_initPtr.asFunction<mraa_pwm_context Function(int)>();

  /// Initialise pwm_context, raw mode
  ///
  /// @param chipid The chip inwhich the PWM is under in SYSFS
  /// @param pin The PWM PIN.
  /// @return pwm context or NULL
  mraa_pwm_context mraa_pwm_init_raw(int chipid, int pin) {
    return _mraa_pwm_init_raw(chipid, pin);
  }

  late final _mraa_pwm_init_rawPtr =
      _lookup<ffi.NativeFunction<mraa_pwm_context Function(ffi.Int, ffi.Int)>>(
        'mraa_pwm_init_raw',
      );
  late final _mraa_pwm_init_raw =
      _mraa_pwm_init_rawPtr.asFunction<mraa_pwm_context Function(int, int)>();

  /// Set the output duty-cycle percentage, as a float
  ///
  /// @param dev The Pwm context to use
  /// @param percentage A floating-point value representing percentage of output.
  /// The value should lie between 0.0f (representing on 0%) and 1.0f
  /// Values above or below this range will be set at either 0.0f or 1.0f
  /// @return Result of operation
  int mraa_pwm_write(mraa_pwm_context dev, double percentage) {
    return _mraa_pwm_write(dev, percentage);
  }

  late final _mraa_pwm_writePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Float)>
  >('mraa_pwm_write');
  late final _mraa_pwm_write =
      _mraa_pwm_writePtr.asFunction<int Function(mraa_pwm_context, double)>();

  /// Read the output duty-cycle percentage, as a float
  ///
  /// @param dev The Pwm context to use
  /// @return percentage A floating-point value representing percentage of output.
  /// The value should lie between 0.0f (representing on 0%) and 1.0f
  /// Values above or below this range will be set at either 0.0f or 1.0f
  double mraa_pwm_read(mraa_pwm_context dev) {
    return _mraa_pwm_read(dev);
  }

  late final _mraa_pwm_readPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(mraa_pwm_context)>>(
        'mraa_pwm_read',
      );
  late final _mraa_pwm_read =
      _mraa_pwm_readPtr.asFunction<double Function(mraa_pwm_context)>();

  /// Set the PWM period as seconds represented in a float
  ///
  /// @param dev The Pwm context to use
  /// @param seconds Period represented as a float in seconds
  /// @return Result of operation
  int mraa_pwm_period(mraa_pwm_context dev, double seconds) {
    return _mraa_pwm_period(dev, seconds);
  }

  late final _mraa_pwm_periodPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Float)>
  >('mraa_pwm_period');
  late final _mraa_pwm_period =
      _mraa_pwm_periodPtr.asFunction<int Function(mraa_pwm_context, double)>();

  /// Set period, milliseconds.
  ///
  /// @param dev The Pwm context to use
  /// @param ms Milliseconds for period
  /// @return Result of operation
  int mraa_pwm_period_ms(mraa_pwm_context dev, int ms) {
    return _mraa_pwm_period_ms(dev, ms);
  }

  late final _mraa_pwm_period_msPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Int)>
  >('mraa_pwm_period_ms');
  late final _mraa_pwm_period_ms =
      _mraa_pwm_period_msPtr.asFunction<int Function(mraa_pwm_context, int)>();

  /// Set period, microseconds
  ///
  /// @param dev The Pwm context to use
  /// @param us Microseconds as period
  /// @return Result of operation
  int mraa_pwm_period_us(mraa_pwm_context dev, int us) {
    return _mraa_pwm_period_us(dev, us);
  }

  late final _mraa_pwm_period_usPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Int)>
  >('mraa_pwm_period_us');
  late final _mraa_pwm_period_us =
      _mraa_pwm_period_usPtr.asFunction<int Function(mraa_pwm_context, int)>();

  /// Set pulsewidth, As represnted by seconds in a (float)
  ///
  /// @param dev The Pwm context to use
  /// @param seconds The duration of a pulse
  /// @return Result of operation
  int mraa_pwm_pulsewidth(mraa_pwm_context dev, double seconds) {
    return _mraa_pwm_pulsewidth(dev, seconds);
  }

  late final _mraa_pwm_pulsewidthPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Float)>
  >('mraa_pwm_pulsewidth');
  late final _mraa_pwm_pulsewidth =
      _mraa_pwm_pulsewidthPtr
          .asFunction<int Function(mraa_pwm_context, double)>();

  /// Set pulsewidth, milliseconds
  ///
  /// @param dev The Pwm context to use
  /// @param ms Milliseconds for pulsewidth
  /// @return Result of operation
  int mraa_pwm_pulsewidth_ms(mraa_pwm_context dev, int ms) {
    return _mraa_pwm_pulsewidth_ms(dev, ms);
  }

  late final _mraa_pwm_pulsewidth_msPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Int)>
  >('mraa_pwm_pulsewidth_ms');
  late final _mraa_pwm_pulsewidth_ms =
      _mraa_pwm_pulsewidth_msPtr
          .asFunction<int Function(mraa_pwm_context, int)>();

  /// Set pulsewidth, microseconds
  ///
  /// @param dev The Pwm context to use
  /// @param us Microseconds for pulsewidth
  /// @return Result of operation
  int mraa_pwm_pulsewidth_us(mraa_pwm_context dev, int us) {
    return _mraa_pwm_pulsewidth_us(dev, us);
  }

  late final _mraa_pwm_pulsewidth_usPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Int)>
  >('mraa_pwm_pulsewidth_us');
  late final _mraa_pwm_pulsewidth_us =
      _mraa_pwm_pulsewidth_usPtr
          .asFunction<int Function(mraa_pwm_context, int)>();

  /// Set the enable status of the PWM pin. None zero will assume on with output being driven.
  /// and 0 will disable the output.
  ///
  /// @param dev The pwm context to use
  /// @param enable Toggle status of pin
  /// @return Result of operation.
  int mraa_pwm_enable(mraa_pwm_context dev, int enable) {
    return _mraa_pwm_enable(dev, enable);
  }

  late final _mraa_pwm_enablePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, ffi.Int)>
  >('mraa_pwm_enable');
  late final _mraa_pwm_enable =
      _mraa_pwm_enablePtr.asFunction<int Function(mraa_pwm_context, int)>();

  /// Change ownership of context
  ///
  /// @param dev the context
  /// @param owner Ownership boolean
  /// @return Result of operation
  int mraa_pwm_owner(mraa_pwm_context dev, int owner) {
    return _mraa_pwm_owner(dev, owner);
  }

  late final _mraa_pwm_ownerPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context, mraa_boolean_t)>
  >('mraa_pwm_owner');
  late final _mraa_pwm_owner =
      _mraa_pwm_ownerPtr.asFunction<int Function(mraa_pwm_context, int)>();

  /// Close and unexport the PWM pin
  ///
  /// @param dev The pwm context to use
  /// @return Result of operation
  int mraa_pwm_close(mraa_pwm_context dev) {
    return _mraa_pwm_close(dev);
  }

  late final _mraa_pwm_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_pwm_context)>>(
        'mraa_pwm_close',
      );
  late final _mraa_pwm_close =
      _mraa_pwm_closePtr.asFunction<int Function(mraa_pwm_context)>();

  /// Get the maximum pwm period in us
  ///
  /// @param dev The pwm context to use
  /// @return max pwm in us
  int mraa_pwm_get_max_period(mraa_pwm_context dev) {
    return _mraa_pwm_get_max_period(dev);
  }

  late final _mraa_pwm_get_max_periodPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_pwm_context)>>(
        'mraa_pwm_get_max_period',
      );
  late final _mraa_pwm_get_max_period =
      _mraa_pwm_get_max_periodPtr.asFunction<int Function(mraa_pwm_context)>();

  /// Get the minimum pwm period in us
  ///
  /// @param dev The pwm context to use
  /// @return min pwm in us
  int mraa_pwm_get_min_period(mraa_pwm_context dev) {
    return _mraa_pwm_get_min_period(dev);
  }

  late final _mraa_pwm_get_min_periodPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_pwm_context)>>(
        'mraa_pwm_get_min_period',
      );
  late final _mraa_pwm_get_min_period =
      _mraa_pwm_get_min_periodPtr.asFunction<int Function(mraa_pwm_context)>();

  /// Initialise gpio_context, based on board number
  ///
  /// @param pin Pin number read from the board, i.e IO3 is 3
  /// @returns gpio context or NULL
  mraa_gpio_context mraa_gpio_init(int pin) {
    return _mraa_gpio_init(pin);
  }

  late final _mraa_gpio_initPtr =
      _lookup<ffi.NativeFunction<mraa_gpio_context Function(ffi.Int)>>(
        'mraa_gpio_init',
      );
  late final _mraa_gpio_init =
      _mraa_gpio_initPtr.asFunction<mraa_gpio_context Function(int)>();

  /// Initialise gpio_context, based on gpio line name
  ///
  /// @param name GPIO line name, i.e GPIO-A
  /// @returns gpio context or NULL
  mraa_gpio_context mraa_gpio_init_by_name(ffi.Pointer<ffi.Char> name) {
    return _mraa_gpio_init_by_name(name);
  }

  late final _mraa_gpio_init_by_namePtr = _lookup<
    ffi.NativeFunction<mraa_gpio_context Function(ffi.Pointer<ffi.Char>)>
  >('mraa_gpio_init_by_name');
  late final _mraa_gpio_init_by_name =
      _mraa_gpio_init_by_namePtr
          .asFunction<mraa_gpio_context Function(ffi.Pointer<ffi.Char>)>();

  /// Initialise gpio_context, based on board number, for multiple pins (can be one).
  ///
  /// @param pins Pin array read from the board
  /// @param num_pins Number of pins - must be the same as the pins array length provided
  /// as the first argument.
  /// @returns gpio context or NULL
  mraa_gpio_context mraa_gpio_init_multi(
    ffi.Pointer<ffi.Int> pins,
    int num_pins,
  ) {
    return _mraa_gpio_init_multi(pins, num_pins);
  }

  late final _mraa_gpio_init_multiPtr = _lookup<
    ffi.NativeFunction<
      mraa_gpio_context Function(ffi.Pointer<ffi.Int>, ffi.Int)
    >
  >('mraa_gpio_init_multi');
  late final _mraa_gpio_init_multi =
      _mraa_gpio_init_multiPtr
          .asFunction<mraa_gpio_context Function(ffi.Pointer<ffi.Int>, int)>();

  /// Initialise gpio context without any mapping to a pin
  ///
  /// @param gpiopin gpio pin as listed in SYSFS
  /// @return gpio context or NULL
  mraa_gpio_context mraa_gpio_init_raw(int gpiopin) {
    return _mraa_gpio_init_raw(gpiopin);
  }

  late final _mraa_gpio_init_rawPtr =
      _lookup<ffi.NativeFunction<mraa_gpio_context Function(ffi.Int)>>(
        'mraa_gpio_init_raw',
      );
  late final _mraa_gpio_init_raw =
      _mraa_gpio_init_rawPtr.asFunction<mraa_gpio_context Function(int)>();

  /// Set the edge mode on the gpio
  ///
  /// @param dev The Gpio context
  /// @param mode The edge mode to set the gpio into
  /// @return Result of operation
  int mraa_gpio_edge_mode(mraa_gpio_context dev, int mode) {
    return _mraa_gpio_edge_mode(dev, mode);
  }

  late final _mraa_gpio_edge_modePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, ffi.Int32)>
  >('mraa_gpio_edge_mode');
  late final _mraa_gpio_edge_mode =
      _mraa_gpio_edge_modePtr
          .asFunction<int Function(mraa_gpio_context, int)>();

  /// Set an interrupt on pin(s).
  ///
  /// @param dev The Gpio context
  /// @param edge The edge mode to set the gpio(s) into
  /// @param fptr Function pointer to function to be called when interrupt is
  /// triggered
  /// @param args Arguments passed to the interrupt handler (fptr)
  /// @return Result of operation
  int mraa_gpio_isr(
    mraa_gpio_context dev,
    int edge,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
    fptr,
    ffi.Pointer<ffi.Void> args,
  ) {
    return _mraa_gpio_isr(dev, edge, fptr, args);
  }

  late final _mraa_gpio_isrPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(
        mraa_gpio_context,
        ffi.Int32,
        ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
        >,
        ffi.Pointer<ffi.Void>,
      )
    >
  >('mraa_gpio_isr');
  late final _mraa_gpio_isr =
      _mraa_gpio_isrPtr
          .asFunction<
            int Function(
              mraa_gpio_context,
              int,
              ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
              >,
              ffi.Pointer<ffi.Void>,
            )
          >();

  /// Get an array of structures describing triggered events.
  ///
  /// @param dev The Gpio context
  /// @return Array of structures containing pairs of pin id's and the associated timestamp.
  /// An event with negative id value indicates that no event was triggered for the respective pin.
  /// The array length is that of the number of pins provided in mraa_gpio_init_multi().
  mraa_gpio_events_t mraa_gpio_get_events(mraa_gpio_context dev) {
    return _mraa_gpio_get_events(dev);
  }

  late final _mraa_gpio_get_eventsPtr = _lookup<
    ffi.NativeFunction<mraa_gpio_events_t Function(mraa_gpio_context)>
  >('mraa_gpio_get_events');
  late final _mraa_gpio_get_events =
      _mraa_gpio_get_eventsPtr
          .asFunction<mraa_gpio_events_t Function(mraa_gpio_context)>();

  /// Stop the current interrupt watcher on this Gpio, and set the Gpio edge mode
  /// to MRAA_GPIO_EDGE_NONE(only for sysfs interface).
  ///
  /// @param dev The Gpio context
  /// @return Result of operation
  int mraa_gpio_isr_exit(mraa_gpio_context dev) {
    return _mraa_gpio_isr_exit(dev);
  }

  late final _mraa_gpio_isr_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context)>>(
        'mraa_gpio_isr_exit',
      );
  late final _mraa_gpio_isr_exit =
      _mraa_gpio_isr_exitPtr.asFunction<int Function(mraa_gpio_context)>();

  /// Set Gpio(s) Output Mode,
  ///
  /// @param dev The Gpio context
  /// @param mode The Gpio(s) Output Mode
  /// @return Result of operation
  int mraa_gpio_mode(mraa_gpio_context dev, int mode) {
    return _mraa_gpio_mode(dev, mode);
  }

  late final _mraa_gpio_modePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, ffi.Int32)>
  >('mraa_gpio_mode');
  late final _mraa_gpio_mode =
      _mraa_gpio_modePtr.asFunction<int Function(mraa_gpio_context, int)>();

  /// Set Gpio(s) direction
  ///
  /// @param dev The Gpio context
  /// @param dir The direction of the Gpio(s)
  /// @return Result of operation
  int mraa_gpio_dir(mraa_gpio_context dev, int dir) {
    return _mraa_gpio_dir(dev, dir);
  }

  late final _mraa_gpio_dirPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, ffi.Int32)>
  >('mraa_gpio_dir');
  late final _mraa_gpio_dir =
      _mraa_gpio_dirPtr.asFunction<int Function(mraa_gpio_context, int)>();

  /// Read Gpio(s) direction
  ///
  /// @param dev The Gpio context
  /// @param dir The address where to store the Gpio(s) direction
  /// @return Result of operation
  int mraa_gpio_read_dir(mraa_gpio_context dev, ffi.Pointer<ffi.Int32> dir) {
    return _mraa_gpio_read_dir(dev, dir);
  }

  late final _mraa_gpio_read_dirPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_gpio_context, ffi.Pointer<ffi.Int32>)
    >
  >('mraa_gpio_read_dir');
  late final _mraa_gpio_read_dir =
      _mraa_gpio_read_dirPtr
          .asFunction<
            int Function(mraa_gpio_context, ffi.Pointer<ffi.Int32>)
          >();

  /// Close the Gpio context
  /// - Will free the memory for the context and unexport the Gpio - sysfs interface.
  /// - Will free up the memory used by context and close related file descriptors - chardev interface.
  ///
  /// @param dev The Gpio context
  /// @return Result of operation
  int mraa_gpio_close(mraa_gpio_context dev) {
    return _mraa_gpio_close(dev);
  }

  late final _mraa_gpio_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context)>>(
        'mraa_gpio_close',
      );
  late final _mraa_gpio_close =
      _mraa_gpio_closePtr.asFunction<int Function(mraa_gpio_context)>();

  /// Read the Gpio value. This can be 0 or 1. A resonse of -1 means that there
  /// was a fatal error.
  ///
  /// @param dev The Gpio context
  /// @return Result of operation
  int mraa_gpio_read(mraa_gpio_context dev) {
    return _mraa_gpio_read(dev);
  }

  late final _mraa_gpio_readPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_gpio_context)>>(
        'mraa_gpio_read',
      );
  late final _mraa_gpio_read =
      _mraa_gpio_readPtr.asFunction<int Function(mraa_gpio_context)>();

  /// Read the Gpio(s) value. The user must provide an integer array with a length equal to the
  /// number of pins provided to mraa_gpio_init_multi() function.
  ///
  /// @param dev The Gpio context
  /// @param output_values The array provided by the user. Existing values will be overwritten with the newly read ones.
  /// @return Result of operation
  int mraa_gpio_read_multi(
    mraa_gpio_context dev,
    ffi.Pointer<ffi.Int> output_values,
  ) {
    return _mraa_gpio_read_multi(dev, output_values);
  }

  late final _mraa_gpio_read_multiPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_gpio_context, ffi.Pointer<ffi.Int>)
    >
  >('mraa_gpio_read_multi');
  late final _mraa_gpio_read_multi =
      _mraa_gpio_read_multiPtr
          .asFunction<int Function(mraa_gpio_context, ffi.Pointer<ffi.Int>)>();

  /// Write to the Gpio Value.
  ///
  /// @param dev The Gpio context
  /// @param value Integer value to write
  /// @return Result of operation
  int mraa_gpio_write(mraa_gpio_context dev, int value) {
    return _mraa_gpio_write(dev, value);
  }

  late final _mraa_gpio_writePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, ffi.Int)>
  >('mraa_gpio_write');
  late final _mraa_gpio_write =
      _mraa_gpio_writePtr.asFunction<int Function(mraa_gpio_context, int)>();

  /// Write to the Gpio(s) Value. The user must provide an integer array with a length equal to the
  /// number of pins provided to mraa_gpio_init_multi() function.
  ///
  /// @param dev The Gpio context
  /// @param output_values The array provided by the user. It must contain the values intended to be written
  /// to the gpio pins, in the same order as the init function.
  /// @return Result of operation
  int mraa_gpio_write_multi(
    mraa_gpio_context dev,
    ffi.Pointer<ffi.Int> input_values,
  ) {
    return _mraa_gpio_write_multi(dev, input_values);
  }

  late final _mraa_gpio_write_multiPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_gpio_context, ffi.Pointer<ffi.Int>)
    >
  >('mraa_gpio_write_multi');
  late final _mraa_gpio_write_multi =
      _mraa_gpio_write_multiPtr
          .asFunction<int Function(mraa_gpio_context, ffi.Pointer<ffi.Int>)>();

  /// Change ownership of the context.
  ///
  /// @param dev The Gpio context
  /// @param owner Does this context own the pin
  /// @return Result of operation
  int mraa_gpio_owner(mraa_gpio_context dev, int owner) {
    return _mraa_gpio_owner(dev, owner);
  }

  late final _mraa_gpio_ownerPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, mraa_boolean_t)>
  >('mraa_gpio_owner');
  late final _mraa_gpio_owner =
      _mraa_gpio_ownerPtr.asFunction<int Function(mraa_gpio_context, int)>();

  /// Enable using memory mapped io instead of sysfs, chardev based I/O can be
  /// considered memorymapped
  ///
  /// @deprecated
  /// @param dev The Gpio context
  /// @param mmap Use mmap instead of sysfs
  /// @return Result of operation
  int mraa_gpio_use_mmaped(mraa_gpio_context dev, int mmap) {
    return _mraa_gpio_use_mmaped(dev, mmap);
  }

  late final _mraa_gpio_use_mmapedPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, mraa_boolean_t)>
  >('mraa_gpio_use_mmaped');
  late final _mraa_gpio_use_mmaped =
      _mraa_gpio_use_mmapedPtr
          .asFunction<int Function(mraa_gpio_context, int)>();

  int mraa_gpio_use_mmaped_internal(mraa_gpio_context dev, int mmap) {
    return _mraa_gpio_use_mmaped_internal(dev, mmap);
  }

  late final _mraa_gpio_use_mmaped_internalPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, mraa_boolean_t)>
  >('mraa_gpio_use_mmaped_internal');
  late final _mraa_gpio_use_mmaped_internal =
      _mraa_gpio_use_mmaped_internalPtr
          .asFunction<int Function(mraa_gpio_context, int)>();

  /// Get a pin number of the gpio, invalid will return -1
  ///
  /// @param dev The Gpio context
  /// @return Pin number
  int mraa_gpio_get_pin(mraa_gpio_context dev) {
    return _mraa_gpio_get_pin(dev);
  }

  late final _mraa_gpio_get_pinPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_gpio_context)>>(
        'mraa_gpio_get_pin',
      );
  late final _mraa_gpio_get_pin =
      _mraa_gpio_get_pinPtr.asFunction<int Function(mraa_gpio_context)>();

  /// Get a gpio number as used within sysfs, invalid will return -1
  ///
  /// @param dev The Gpio context
  /// @return gpio number
  int mraa_gpio_get_pin_raw(mraa_gpio_context dev) {
    return _mraa_gpio_get_pin_raw(dev);
  }

  late final _mraa_gpio_get_pin_rawPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_gpio_context)>>(
        'mraa_gpio_get_pin_raw',
      );
  late final _mraa_gpio_get_pin_raw =
      _mraa_gpio_get_pin_rawPtr.asFunction<int Function(mraa_gpio_context)>();

  /// Set Gpio input mode
  ///
  /// @param dev The Gpio context
  /// @param mode Mode to set input pin state
  /// @return Result of operation
  int mraa_gpio_input_mode(mraa_gpio_context dev, int mode) {
    return _mraa_gpio_input_mode(dev, mode);
  }

  late final _mraa_gpio_input_modePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, ffi.Int32)>
  >('mraa_gpio_input_mode');
  late final _mraa_gpio_input_mode =
      _mraa_gpio_input_modePtr
          .asFunction<int Function(mraa_gpio_context, int)>();

  /// Set Gpio output driver mode. This is not a standard feature, it needs custom implementation for each board
  ///
  /// @param dev The Gpio context
  /// @param mode Set output driver mode
  /// @return Result of operation
  int mraa_gpio_out_driver_mode(mraa_gpio_context dev, int mode) {
    return _mraa_gpio_out_driver_mode(dev, mode);
  }

  late final _mraa_gpio_out_driver_modePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_gpio_context, ffi.Int32)>
  >('mraa_gpio_out_driver_mode');
  late final _mraa_gpio_out_driver_mode =
      _mraa_gpio_out_driver_modePtr
          .asFunction<int Function(mraa_gpio_context, int)>();

  /// Initialise an Analog input device, connected to the specified pin. Aio pins
  /// are always 0 indexed reguardless of their position. Check your board mapping
  /// for details. An arduino style layout will have A0 as pin14 but AIO0.
  ///
  /// @param pin Channel number to read ADC inputs
  /// @returns aio context or NULL
  mraa_aio_context mraa_aio_init(int pin) {
    return _mraa_aio_init(pin);
  }

  late final _mraa_aio_initPtr =
      _lookup<ffi.NativeFunction<mraa_aio_context Function(ffi.UnsignedInt)>>(
        'mraa_aio_init',
      );
  late final _mraa_aio_init =
      _mraa_aio_initPtr.asFunction<mraa_aio_context Function(int)>();

  /// Read the input voltage. By default mraa will shift the raw value up or down
  /// to a 10 bit value.
  ///
  /// @param dev The AIO context
  /// @returns The current input voltage or -1 for error
  int mraa_aio_read(mraa_aio_context dev) {
    return _mraa_aio_read(dev);
  }

  late final _mraa_aio_readPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_aio_context)>>(
        'mraa_aio_read',
      );
  late final _mraa_aio_read =
      _mraa_aio_readPtr.asFunction<int Function(mraa_aio_context)>();

  /// Read the input voltage and return it as a normalized float (0.0f-1.0f).
  ///
  /// @param dev The AIO context
  /// @returns The current input voltage as a normalized float (0.0f-1.0f), error
  /// will be signaled by -1.0f
  double mraa_aio_read_float(mraa_aio_context dev) {
    return _mraa_aio_read_float(dev);
  }

  late final _mraa_aio_read_floatPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(mraa_aio_context)>>(
        'mraa_aio_read_float',
      );
  late final _mraa_aio_read_float =
      _mraa_aio_read_floatPtr.asFunction<double Function(mraa_aio_context)>();

  /// Close the analog input context, this will free the memory for the context
  ///
  /// @param dev The AIO context
  /// @return Result of operation
  int mraa_aio_close(mraa_aio_context dev) {
    return _mraa_aio_close(dev);
  }

  late final _mraa_aio_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_aio_context)>>(
        'mraa_aio_close',
      );
  late final _mraa_aio_close =
      _mraa_aio_closePtr.asFunction<int Function(mraa_aio_context)>();

  /// Set the bit value which mraa will shift the raw reading
  /// from the ADC to. I.e. 10bits
  /// @param dev the analog input context
  /// @param bits the bits the return from read should be i.e 10
  ///
  /// @return mraa result type
  int mraa_aio_set_bit(mraa_aio_context dev, int bits) {
    return _mraa_aio_set_bit(dev, bits);
  }

  late final _mraa_aio_set_bitPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_aio_context, ffi.Int)>
  >('mraa_aio_set_bit');
  late final _mraa_aio_set_bit =
      _mraa_aio_set_bitPtr.asFunction<int Function(mraa_aio_context, int)>();

  /// Gets the bit value mraa is shifting the analog read to.
  /// @param dev the analog input context
  ///
  /// @return bit value mraa is set return from the read function
  int mraa_aio_get_bit(mraa_aio_context dev) {
    return _mraa_aio_get_bit(dev);
  }

  late final _mraa_aio_get_bitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_aio_context)>>(
        'mraa_aio_get_bit',
      );
  late final _mraa_aio_get_bit =
      _mraa_aio_get_bitPtr.asFunction<int Function(mraa_aio_context)>();

  /// Initialise SPI_context, uses board mapping. Sets the muxes
  ///
  /// @param bus Bus to use, as listed in platform definition, normally 0
  /// @return Spi context or NULL
  mraa_spi_context mraa_spi_init(int bus) {
    return _mraa_spi_init(bus);
  }

  late final _mraa_spi_initPtr =
      _lookup<ffi.NativeFunction<mraa_spi_context Function(ffi.Int)>>(
        'mraa_spi_init',
      );
  late final _mraa_spi_init =
      _mraa_spi_initPtr.asFunction<mraa_spi_context Function(int)>();

  /// Initialise SPI_context without any board configuration, selects a bus and a mux.
  ///
  /// @param bus Bus to use as listed by spidev
  /// @param cs Chip select to use as listed in spidev
  /// @return Spi context or NULL
  mraa_spi_context mraa_spi_init_raw(int bus, int cs) {
    return _mraa_spi_init_raw(bus, cs);
  }

  late final _mraa_spi_init_rawPtr = _lookup<
    ffi.NativeFunction<
      mraa_spi_context Function(ffi.UnsignedInt, ffi.UnsignedInt)
    >
  >('mraa_spi_init_raw');
  late final _mraa_spi_init_raw =
      _mraa_spi_init_rawPtr.asFunction<mraa_spi_context Function(int, int)>();

  /// Set the SPI device mode. see spidev 0-3.
  ///
  /// @param dev The Spi context
  /// @param mode The SPI mode, See Linux spidev
  /// @return Result of operation
  int mraa_spi_mode(mraa_spi_context dev, int mode) {
    return _mraa_spi_mode(dev, mode);
  }

  late final _mraa_spi_modePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_spi_context, ffi.Int32)>
  >('mraa_spi_mode');
  late final _mraa_spi_mode =
      _mraa_spi_modePtr.asFunction<int Function(mraa_spi_context, int)>();

  /// Set the SPI device operating clock frequency.
  ///
  /// @param dev the Spi context
  /// @param hz the frequency in hz
  /// @return Result of operation
  int mraa_spi_frequency(mraa_spi_context dev, int hz) {
    return _mraa_spi_frequency(dev, hz);
  }

  late final _mraa_spi_frequencyPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_spi_context, ffi.Int)>
  >('mraa_spi_frequency');
  late final _mraa_spi_frequency =
      _mraa_spi_frequencyPtr.asFunction<int Function(mraa_spi_context, int)>();

  /// Write Single Byte to the SPI device.
  ///
  /// @param dev The Spi context
  /// @param data Data to send
  /// @return Data received on the miso line or -1 in case of error
  int mraa_spi_write(mraa_spi_context dev, int data) {
    return _mraa_spi_write(dev, data);
  }

  late final _mraa_spi_writePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(mraa_spi_context, ffi.Uint8)>
  >('mraa_spi_write');
  late final _mraa_spi_write =
      _mraa_spi_writePtr.asFunction<int Function(mraa_spi_context, int)>();

  /// Write Two Bytes to the SPI device.
  ///
  /// @param dev The Spi context
  /// @param data Data to send
  /// @return Data received on the miso line
  int mraa_spi_write_word(mraa_spi_context dev, int data) {
    return _mraa_spi_write_word(dev, data);
  }

  late final _mraa_spi_write_wordPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(mraa_spi_context, ffi.Uint16)>
  >('mraa_spi_write_word');
  late final _mraa_spi_write_word =
      _mraa_spi_write_wordPtr.asFunction<int Function(mraa_spi_context, int)>();

  /// Write Buffer of bytes to the SPI device. The pointer return has to be
  /// free'd by the caller. It will return a NULL pointer in cases of error.
  ///
  /// @param dev The Spi context
  /// @param data to send
  /// @param length elements within buffer, Max 4096
  /// @return Data received on the miso line, same length as passed in
  ffi.Pointer<ffi.Uint8> mraa_spi_write_buf(
    mraa_spi_context dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _mraa_spi_write_buf(dev, data, length);
  }

  late final _mraa_spi_write_bufPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Uint8> Function(
        mraa_spi_context,
        ffi.Pointer<ffi.Uint8>,
        ffi.Int,
      )
    >
  >('mraa_spi_write_buf');
  late final _mraa_spi_write_buf =
      _mraa_spi_write_bufPtr
          .asFunction<
            ffi.Pointer<ffi.Uint8> Function(
              mraa_spi_context,
              ffi.Pointer<ffi.Uint8>,
              int,
            )
          >();

  /// Write Buffer of uint16 to the SPI device. The pointer return has to be
  /// free'd by the caller. It will return a NULL pointer in cases of error.
  ///
  /// @param dev The Spi context
  /// @param data to send
  /// @param length elements (in bytes) within buffer, Max 4096
  /// @return Data received on the miso line, same length as passed in
  ffi.Pointer<ffi.Uint16> mraa_spi_write_buf_word(
    mraa_spi_context dev,
    ffi.Pointer<ffi.Uint16> data,
    int length,
  ) {
    return _mraa_spi_write_buf_word(dev, data, length);
  }

  late final _mraa_spi_write_buf_wordPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Uint16> Function(
        mraa_spi_context,
        ffi.Pointer<ffi.Uint16>,
        ffi.Int,
      )
    >
  >('mraa_spi_write_buf_word');
  late final _mraa_spi_write_buf_word =
      _mraa_spi_write_buf_wordPtr
          .asFunction<
            ffi.Pointer<ffi.Uint16> Function(
              mraa_spi_context,
              ffi.Pointer<ffi.Uint16>,
              int,
            )
          >();

  /// Transfer Buffer of bytes to the SPI device. Both send and recv buffers
  /// are passed in
  ///
  /// @param dev The Spi context
  /// @param data to send
  /// @param rxbuf buffer to recv data back, may be NULL
  /// @param length elements within buffer, Max 4096
  /// @return Result of operation
  int mraa_spi_transfer_buf(
    mraa_spi_context dev,
    ffi.Pointer<ffi.Uint8> data,
    ffi.Pointer<ffi.Uint8> rxbuf,
    int length,
  ) {
    return _mraa_spi_transfer_buf(dev, data, rxbuf, length);
  }

  late final _mraa_spi_transfer_bufPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(
        mraa_spi_context,
        ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Int,
      )
    >
  >('mraa_spi_transfer_buf');
  late final _mraa_spi_transfer_buf =
      _mraa_spi_transfer_bufPtr
          .asFunction<
            int Function(
              mraa_spi_context,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              int,
            )
          >();

  /// Transfer Buffer of uint16 to the SPI device. Both send and recv buffers
  /// are passed in
  ///
  /// @param dev The Spi context
  /// @param data to send
  /// @param rxbuf buffer to recv data back, may be NULL
  /// @param length elements (in bytes) within buffer, Max 4096
  /// @return Result of operation
  int mraa_spi_transfer_buf_word(
    mraa_spi_context dev,
    ffi.Pointer<ffi.Uint16> data,
    ffi.Pointer<ffi.Uint16> rxbuf,
    int length,
  ) {
    return _mraa_spi_transfer_buf_word(dev, data, rxbuf, length);
  }

  late final _mraa_spi_transfer_buf_wordPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(
        mraa_spi_context,
        ffi.Pointer<ffi.Uint16>,
        ffi.Pointer<ffi.Uint16>,
        ffi.Int,
      )
    >
  >('mraa_spi_transfer_buf_word');
  late final _mraa_spi_transfer_buf_word =
      _mraa_spi_transfer_buf_wordPtr
          .asFunction<
            int Function(
              mraa_spi_context,
              ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.Uint16>,
              int,
            )
          >();

  /// Change the SPI lsb mode
  ///
  /// @param dev The Spi context
  /// @param lsb Use least significant bit transmission. 0 for msbi
  /// @return Result of operation
  int mraa_spi_lsbmode(mraa_spi_context dev, int lsb) {
    return _mraa_spi_lsbmode(dev, lsb);
  }

  late final _mraa_spi_lsbmodePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_spi_context, mraa_boolean_t)>
  >('mraa_spi_lsbmode');
  late final _mraa_spi_lsbmode =
      _mraa_spi_lsbmodePtr.asFunction<int Function(mraa_spi_context, int)>();

  /// Set bits per mode on transaction, defaults at 8
  ///
  /// @param dev The Spi context
  /// @param bits bits per word
  /// @return Result of operation
  int mraa_spi_bit_per_word(mraa_spi_context dev, int bits) {
    return _mraa_spi_bit_per_word(dev, bits);
  }

  late final _mraa_spi_bit_per_wordPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_spi_context, ffi.UnsignedInt)>
  >('mraa_spi_bit_per_word');
  late final _mraa_spi_bit_per_word =
      _mraa_spi_bit_per_wordPtr
          .asFunction<int Function(mraa_spi_context, int)>();

  /// De-inits an mraa_spi_context device
  ///
  /// @param dev The Spi context
  /// @return Result of operation
  int mraa_spi_stop(mraa_spi_context dev) {
    return _mraa_spi_stop(dev);
  }

  late final _mraa_spi_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_spi_context)>>(
        'mraa_spi_stop',
      );
  late final _mraa_spi_stop =
      _mraa_spi_stopPtr.asFunction<int Function(mraa_spi_context)>();

  /// Initialise i2c context, using board defintions
  ///
  /// @param bus i2c bus to use
  /// @return i2c context or NULL
  mraa_i2c_context mraa_i2c_init(int bus) {
    return _mraa_i2c_init(bus);
  }

  late final _mraa_i2c_initPtr =
      _lookup<ffi.NativeFunction<mraa_i2c_context Function(ffi.Int)>>(
        'mraa_i2c_init',
      );
  late final _mraa_i2c_init =
      _mraa_i2c_initPtr.asFunction<mraa_i2c_context Function(int)>();

  /// Initialise i2c context, passing in the i2c bus to use.
  ///
  /// @param bus The i2c bus to use i.e. /dev/i2c-2 would be "2"
  /// @return i2c context or NULL
  mraa_i2c_context mraa_i2c_init_raw(int bus) {
    return _mraa_i2c_init_raw(bus);
  }

  late final _mraa_i2c_init_rawPtr =
      _lookup<ffi.NativeFunction<mraa_i2c_context Function(ffi.UnsignedInt)>>(
        'mraa_i2c_init_raw',
      );
  late final _mraa_i2c_init_raw =
      _mraa_i2c_init_rawPtr.asFunction<mraa_i2c_context Function(int)>();

  /// Sets the frequency of the i2c context. Most platforms do not support this.
  ///
  /// @param dev The i2c context
  /// @param mode The bus mode
  /// @return Result of operation
  int mraa_i2c_frequency(mraa_i2c_context dev, int mode) {
    return _mraa_i2c_frequency(dev, mode);
  }

  late final _mraa_i2c_frequencyPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_i2c_context, ffi.Int32)>
  >('mraa_i2c_frequency');
  late final _mraa_i2c_frequency =
      _mraa_i2c_frequencyPtr.asFunction<int Function(mraa_i2c_context, int)>();

  /// Simple bulk read from an i2c context
  ///
  /// @param dev The i2c context
  /// @param data pointer to the byte array to read data in to
  /// @param length max number of bytes to read
  /// @return length of the read in bytes or -1
  int mraa_i2c_read(
    mraa_i2c_context dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _mraa_i2c_read(dev, data, length);
  }

  late final _mraa_i2c_readPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(mraa_i2c_context, ffi.Pointer<ffi.Uint8>, ffi.Int)
    >
  >('mraa_i2c_read');
  late final _mraa_i2c_read =
      _mraa_i2c_readPtr
          .asFunction<
            int Function(mraa_i2c_context, ffi.Pointer<ffi.Uint8>, int)
          >();

  /// Simple read for a single byte from the i2c context
  ///
  /// @param dev The i2c context
  /// @return The result of the read or -1 if failed
  int mraa_i2c_read_byte(mraa_i2c_context dev) {
    return _mraa_i2c_read_byte(dev);
  }

  late final _mraa_i2c_read_bytePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_i2c_context)>>(
        'mraa_i2c_read_byte',
      );
  late final _mraa_i2c_read_byte =
      _mraa_i2c_read_bytePtr.asFunction<int Function(mraa_i2c_context)>();

  /// Read a single byte from i2c context, from designated register
  ///
  /// @param dev The i2c context
  /// @param command The register
  /// @return The result of the read or -1 if failed
  int mraa_i2c_read_byte_data(mraa_i2c_context dev, int command) {
    return _mraa_i2c_read_byte_data(dev, command);
  }

  late final _mraa_i2c_read_byte_dataPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(mraa_i2c_context, ffi.Uint8)>
  >('mraa_i2c_read_byte_data');
  late final _mraa_i2c_read_byte_data =
      _mraa_i2c_read_byte_dataPtr
          .asFunction<int Function(mraa_i2c_context, int)>();

  /// Read a single word from i2c context, from designated register
  ///
  /// @param dev The i2c context
  /// @param command The register
  /// @return The result of the read or -1 if failed
  int mraa_i2c_read_word_data(mraa_i2c_context dev, int command) {
    return _mraa_i2c_read_word_data(dev, command);
  }

  late final _mraa_i2c_read_word_dataPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(mraa_i2c_context, ffi.Uint8)>
  >('mraa_i2c_read_word_data');
  late final _mraa_i2c_read_word_data =
      _mraa_i2c_read_word_dataPtr
          .asFunction<int Function(mraa_i2c_context, int)>();

  /// Bulk read from i2c context, starting from designated register
  ///
  /// @param dev The i2c context
  /// @param command The register
  /// @param data pointer to the byte array to read data in to
  /// @param length max number of bytes to read
  /// @return The length in bytes passed to the function or -1
  int mraa_i2c_read_bytes_data(
    mraa_i2c_context dev,
    int command,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _mraa_i2c_read_bytes_data(dev, command, data, length);
  }

  late final _mraa_i2c_read_bytes_dataPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        mraa_i2c_context,
        ffi.Uint8,
        ffi.Pointer<ffi.Uint8>,
        ffi.Int,
      )
    >
  >('mraa_i2c_read_bytes_data');
  late final _mraa_i2c_read_bytes_data =
      _mraa_i2c_read_bytes_dataPtr
          .asFunction<
            int Function(mraa_i2c_context, int, ffi.Pointer<ffi.Uint8>, int)
          >();

  /// Write length bytes to the bus, the first byte in the array is the
  /// command/register to write
  ///
  /// @param dev The i2c context
  /// @param data pointer to the byte array to be written
  /// @param length the number of bytes to transmit
  /// @return Result of operation
  int mraa_i2c_write(
    mraa_i2c_context dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _mraa_i2c_write(dev, data, length);
  }

  late final _mraa_i2c_writePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_i2c_context, ffi.Pointer<ffi.Uint8>, ffi.Int)
    >
  >('mraa_i2c_write');
  late final _mraa_i2c_write =
      _mraa_i2c_writePtr
          .asFunction<
            int Function(mraa_i2c_context, ffi.Pointer<ffi.Uint8>, int)
          >();

  /// Write a single byte to an i2c context
  ///
  /// @param dev The i2c context
  /// @param data The byte to write
  /// @return Result of operation
  int mraa_i2c_write_byte(mraa_i2c_context dev, int data) {
    return _mraa_i2c_write_byte(dev, data);
  }

  late final _mraa_i2c_write_bytePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_i2c_context, ffi.Uint8)>
  >('mraa_i2c_write_byte');
  late final _mraa_i2c_write_byte =
      _mraa_i2c_write_bytePtr.asFunction<int Function(mraa_i2c_context, int)>();

  /// Write a single byte to an i2c context
  ///
  /// @param dev The i2c context
  /// @param data The byte to write
  /// @param command The register
  /// @return Result of operation
  int mraa_i2c_write_byte_data(mraa_i2c_context dev, int data, int command) {
    return _mraa_i2c_write_byte_data(dev, data, command);
  }

  late final _mraa_i2c_write_byte_dataPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_i2c_context, ffi.Uint8, ffi.Uint8)
    >
  >('mraa_i2c_write_byte_data');
  late final _mraa_i2c_write_byte_data =
      _mraa_i2c_write_byte_dataPtr
          .asFunction<int Function(mraa_i2c_context, int, int)>();

  /// Write a single word to an i2c context
  ///
  /// @param dev The i2c context
  /// @param data The word to write
  /// @param command The register
  /// @return Result of operation
  int mraa_i2c_write_word_data(mraa_i2c_context dev, int data, int command) {
    return _mraa_i2c_write_word_data(dev, data, command);
  }

  late final _mraa_i2c_write_word_dataPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_i2c_context, ffi.Uint16, ffi.Uint8)
    >
  >('mraa_i2c_write_word_data');
  late final _mraa_i2c_write_word_data =
      _mraa_i2c_write_word_dataPtr
          .asFunction<int Function(mraa_i2c_context, int, int)>();

  /// Sets the i2c slave address.
  ///
  /// @param dev The i2c context
  /// @param address The address to set for the slave (7-bit address)
  /// @return Result of operation
  int mraa_i2c_address(mraa_i2c_context dev, int address) {
    return _mraa_i2c_address(dev, address);
  }

  late final _mraa_i2c_addressPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_i2c_context, ffi.Uint8)>
  >('mraa_i2c_address');
  late final _mraa_i2c_address =
      _mraa_i2c_addressPtr.asFunction<int Function(mraa_i2c_context, int)>();

  /// De-inits an mraa_i2c_context device
  ///
  /// @param dev The i2c context
  /// @return Result of operation
  int mraa_i2c_stop(mraa_i2c_context dev) {
    return _mraa_i2c_stop(dev);
  }

  late final _mraa_i2c_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_i2c_context)>>(
        'mraa_i2c_stop',
      );
  late final _mraa_i2c_stop =
      _mraa_i2c_stopPtr.asFunction<int Function(mraa_i2c_context)>();

  /// Initialise uart_context, uses board mapping
  ///
  /// @param uart the index of the uart set to use
  /// @return uart context or NULL
  mraa_uart_context mraa_uart_init(int uart) {
    return _mraa_uart_init(uart);
  }

  late final _mraa_uart_initPtr =
      _lookup<ffi.NativeFunction<mraa_uart_context Function(ffi.Int)>>(
        'mraa_uart_init',
      );
  late final _mraa_uart_init =
      _mraa_uart_initPtr.asFunction<mraa_uart_context Function(int)>();

  /// Initialise a raw uart_context. No board setup.
  ///
  /// @param path for example "/dev/ttyS0"
  /// @return uart context or NULL
  mraa_uart_context mraa_uart_init_raw(ffi.Pointer<ffi.Char> path) {
    return _mraa_uart_init_raw(path);
  }

  late final _mraa_uart_init_rawPtr = _lookup<
    ffi.NativeFunction<mraa_uart_context Function(ffi.Pointer<ffi.Char>)>
  >('mraa_uart_init_raw');
  late final _mraa_uart_init_raw =
      _mraa_uart_init_rawPtr
          .asFunction<mraa_uart_context Function(ffi.Pointer<ffi.Char>)>();

  /// Flush the outbound data.
  /// Blocks until complete.
  ///
  /// @param dev The UART context
  /// @return Result of operation
  int mraa_uart_flush(mraa_uart_context dev) {
    return _mraa_uart_flush(dev);
  }

  late final _mraa_uart_flushPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_uart_context)>>(
        'mraa_uart_flush',
      );
  late final _mraa_uart_flush =
      _mraa_uart_flushPtr.asFunction<int Function(mraa_uart_context)>();

  /// Send a break to the device.
  /// Blocks until complete.
  ///
  /// @param dev The UART context
  /// @param duration When 0, send a break lasting at least 250
  /// milliseconds, and not more than 500 milliseconds.  When non zero,
  /// the break duration is implementation specific.
  /// @return Result of operation
  int mraa_uart_sendbreak(mraa_uart_context dev, int duration) {
    return _mraa_uart_sendbreak(dev, duration);
  }

  late final _mraa_uart_sendbreakPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_uart_context, ffi.Int)>
  >('mraa_uart_sendbreak');
  late final _mraa_uart_sendbreak =
      _mraa_uart_sendbreakPtr
          .asFunction<int Function(mraa_uart_context, int)>();

  /// Set the baudrate.
  /// Takes an int and will attempt to decide what baudrate  is
  /// to be used on the UART hardware.
  ///
  /// @param dev The UART context
  /// @param baud unsigned int of baudrate i.e. 9600
  /// @return Result of operation
  int mraa_uart_set_baudrate(mraa_uart_context dev, int baud) {
    return _mraa_uart_set_baudrate(dev, baud);
  }

  late final _mraa_uart_set_baudratePtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_uart_context, ffi.UnsignedInt)>
  >('mraa_uart_set_baudrate');
  late final _mraa_uart_set_baudrate =
      _mraa_uart_set_baudratePtr
          .asFunction<int Function(mraa_uart_context, int)>();

  /// Set the transfer mode
  /// For example setting the mode to 8N1 would be
  /// "mraa_uart_set_mode(dev, 8,MRAA_UART_PARITY_NONE , 1)"
  ///
  /// @param dev The UART context
  /// @param bytesize data bits
  /// @param parity Parity bit setting
  /// @param stopbits stop bits
  /// @return Result of operation
  int mraa_uart_set_mode(
    mraa_uart_context dev,
    int bytesize,
    int parity,
    int stopbits,
  ) {
    return _mraa_uart_set_mode(dev, bytesize, parity, stopbits);
  }

  late final _mraa_uart_set_modePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_uart_context, ffi.Int, ffi.Int32, ffi.Int)
    >
  >('mraa_uart_set_mode');
  late final _mraa_uart_set_mode =
      _mraa_uart_set_modePtr
          .asFunction<int Function(mraa_uart_context, int, int, int)>();

  /// Set the flowcontrol
  ///
  /// @param dev The UART context
  /// @param xonxoff XON/XOFF Software flow control.
  /// @param rtscts RTS/CTS out of band hardware flow control
  /// @return Result of operation
  int mraa_uart_set_flowcontrol(
    mraa_uart_context dev,
    int xonxoff,
    int rtscts,
  ) {
    return _mraa_uart_set_flowcontrol(dev, xonxoff, rtscts);
  }

  late final _mraa_uart_set_flowcontrolPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_uart_context, mraa_boolean_t, mraa_boolean_t)
    >
  >('mraa_uart_set_flowcontrol');
  late final _mraa_uart_set_flowcontrol =
      _mraa_uart_set_flowcontrolPtr
          .asFunction<int Function(mraa_uart_context, int, int)>();

  /// Set the timeout for read and write operations
  /// <= 0 will disable that timeout
  ///
  /// @param dev The UART context
  /// @param read read timeout
  /// @param write write timeout
  /// @param interchar inbetween char timeout
  /// @return Result of operation
  int mraa_uart_set_timeout(
    mraa_uart_context dev,
    int read,
    int write,
    int interchar,
  ) {
    return _mraa_uart_set_timeout(dev, read, write, interchar);
  }

  late final _mraa_uart_set_timeoutPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_uart_context, ffi.Int, ffi.Int, ffi.Int)
    >
  >('mraa_uart_set_timeout');
  late final _mraa_uart_set_timeout =
      _mraa_uart_set_timeoutPtr
          .asFunction<int Function(mraa_uart_context, int, int, int)>();

  /// Set the blocking state for write operations
  ///
  /// @param dev The UART context
  /// @param nonblock new nonblocking state
  /// @return Result of operation
  int mraa_uart_set_non_blocking(mraa_uart_context dev, int nonblock) {
    return _mraa_uart_set_non_blocking(dev, nonblock);
  }

  late final _mraa_uart_set_non_blockingPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_uart_context, mraa_boolean_t)>
  >('mraa_uart_set_non_blocking');
  late final _mraa_uart_set_non_blocking =
      _mraa_uart_set_non_blockingPtr
          .asFunction<int Function(mraa_uart_context, int)>();

  /// Get Char pointer with tty device path within Linux
  /// For example. Could point to "/dev/ttyS0"
  ///
  /// @param dev uart context
  /// @return char pointer of device path
  ffi.Pointer<ffi.Char> mraa_uart_get_dev_path(mraa_uart_context dev) {
    return _mraa_uart_get_dev_path(dev);
  }

  late final _mraa_uart_get_dev_pathPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(mraa_uart_context)>
  >('mraa_uart_get_dev_path');
  late final _mraa_uart_get_dev_path =
      _mraa_uart_get_dev_pathPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(mraa_uart_context)>();

  /// Get the current settings of an UART. This is an unintrusive function. Meaning
  /// it intends not to change anything, only read the values without disturbing.
  ///
  /// All but the first index parameter are "outparameters". That means they can
  /// contain values on return. If any parameter is not interesting, a null pointer
  /// can be sent instead as a placeholder.
  /// The devpath parameter can be either in or out parameter. In case of a negative
  /// index,  the UART is identified using *devpath instead. This functionality is
  /// intended for and needed by for instance USB serial adapters.
  ///
  /// In case of a non-success return value, the outparameters are undefined.
  ///
  /// @param index uart index to look up, if negative, *devpath will be used instead
  /// @param devpath points to the device path of the UART, eg: /dev/ttyS0
  /// @param name outparameter that on return will point to the name of the UART
  /// @param baudrate pointer to an integer to contain the current baudrate (0--4M)
  /// @param databits pointer to an integer to contain the number databits (5--8)
  /// @param stopbits pointer to an integer to contain the number stopbits (1--2)
  /// @param parity will contain the current parity mode
  /// @param rtscts will point to true if CTS/RTS flow control is enabled
  /// @param xonxoff will point to a true if xon/xoff flow control is enabled
  /// @return result
  int mraa_uart_settings(
    int index,
    ffi.Pointer<ffi.Pointer<ffi.Char>> devpath,
    ffi.Pointer<ffi.Pointer<ffi.Char>> name,
    ffi.Pointer<ffi.Int> baudrate,
    ffi.Pointer<ffi.Int> databits,
    ffi.Pointer<ffi.Int> stopbits,
    ffi.Pointer<ffi.Int32> parity,
    ffi.Pointer<mraa_boolean_t> rtscts,
    ffi.Pointer<mraa_boolean_t> xonxoff,
  ) {
    return _mraa_uart_settings(
      index,
      devpath,
      name,
      baudrate,
      databits,
      stopbits,
      parity,
      rtscts,
      xonxoff,
    );
  }

  late final _mraa_uart_settingsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(
        ffi.Int,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int32>,
        ffi.Pointer<mraa_boolean_t>,
        ffi.Pointer<mraa_boolean_t>,
      )
    >
  >('mraa_uart_settings');
  late final _mraa_uart_settings =
      _mraa_uart_settingsPtr
          .asFunction<
            int Function(
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<mraa_boolean_t>,
              ffi.Pointer<mraa_boolean_t>,
            )
          >();

  /// Destroy a mraa_uart_context
  ///
  /// @param dev uart context
  /// @return mraa_result_t
  int mraa_uart_stop(mraa_uart_context dev) {
    return _mraa_uart_stop(dev);
  }

  late final _mraa_uart_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_uart_context)>>(
        'mraa_uart_stop',
      );
  late final _mraa_uart_stop =
      _mraa_uart_stopPtr.asFunction<int Function(mraa_uart_context)>();

  /// Read bytes from the device into a buffer
  ///
  /// @param dev uart context
  /// @param buf buffer pointer
  /// @param length maximum size of buffer
  /// @return the number of bytes read, or -1 if an error occurred
  int mraa_uart_read(
    mraa_uart_context dev,
    ffi.Pointer<ffi.Char> buf,
    int length,
  ) {
    return _mraa_uart_read(dev, buf, length);
  }

  late final _mraa_uart_readPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(mraa_uart_context, ffi.Pointer<ffi.Char>, ffi.Size)
    >
  >('mraa_uart_read');
  late final _mraa_uart_read =
      _mraa_uart_readPtr
          .asFunction<
            int Function(mraa_uart_context, ffi.Pointer<ffi.Char>, int)
          >();

  /// Write bytes in buffer to a device
  ///
  /// @param dev uart context
  /// @param buf buffer pointer
  /// @param length maximum size of buffer
  /// @return the number of bytes written, or -1 if an error occurred
  int mraa_uart_write(
    mraa_uart_context dev,
    ffi.Pointer<ffi.Char> buf,
    int length,
  ) {
    return _mraa_uart_write(dev, buf, length);
  }

  late final _mraa_uart_writePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(mraa_uart_context, ffi.Pointer<ffi.Char>, ffi.Size)
    >
  >('mraa_uart_write');
  late final _mraa_uart_write =
      _mraa_uart_writePtr
          .asFunction<
            int Function(mraa_uart_context, ffi.Pointer<ffi.Char>, int)
          >();

  /// Check to see if data is available on the device for reading
  ///
  /// @param dev uart context
  /// @param millis number of milliseconds to wait, or 0 to return immediately
  /// @return 1 if there is data available to read, 0 otherwise
  int mraa_uart_data_available(mraa_uart_context dev, int millis) {
    return _mraa_uart_data_available(dev, millis);
  }

  late final _mraa_uart_data_availablePtr = _lookup<
    ffi.NativeFunction<
      mraa_boolean_t Function(mraa_uart_context, ffi.UnsignedInt)
    >
  >('mraa_uart_data_available');
  late final _mraa_uart_data_available =
      _mraa_uart_data_availablePtr
          .asFunction<int Function(mraa_uart_context, int)>();

  /// Initialise uart_ow_context, uses UART board mapping
  ///
  /// @param uart the index of the uart set to use
  /// @return uart_ow context or NULL
  mraa_uart_ow_context mraa_uart_ow_init(int uart) {
    return _mraa_uart_ow_init(uart);
  }

  late final _mraa_uart_ow_initPtr =
      _lookup<ffi.NativeFunction<mraa_uart_ow_context Function(ffi.Int)>>(
        'mraa_uart_ow_init',
      );
  late final _mraa_uart_ow_init =
      _mraa_uart_ow_initPtr.asFunction<mraa_uart_ow_context Function(int)>();

  /// Initialise a raw uart_ow_context. No board setup.
  ///
  /// @param path for example "/dev/ttyS0"
  /// @return uart_ow context or NULL
  mraa_uart_ow_context mraa_uart_ow_init_raw(ffi.Pointer<ffi.Char> path) {
    return _mraa_uart_ow_init_raw(path);
  }

  late final _mraa_uart_ow_init_rawPtr = _lookup<
    ffi.NativeFunction<mraa_uart_ow_context Function(ffi.Pointer<ffi.Char>)>
  >('mraa_uart_ow_init_raw');
  late final _mraa_uart_ow_init_raw =
      _mraa_uart_ow_init_rawPtr
          .asFunction<mraa_uart_ow_context Function(ffi.Pointer<ffi.Char>)>();

  /// Get char pointer with tty device path within Linux
  /// For example. Could point to "/dev/ttyS0"
  ///
  /// @param dev uart_ow context
  /// @return char pointer of device path
  ffi.Pointer<ffi.Char> mraa_uart_ow_get_dev_path(mraa_uart_ow_context dev) {
    return _mraa_uart_ow_get_dev_path(dev);
  }

  late final _mraa_uart_ow_get_dev_pathPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(mraa_uart_ow_context)>
  >('mraa_uart_ow_get_dev_path');
  late final _mraa_uart_ow_get_dev_path =
      _mraa_uart_ow_get_dev_pathPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(mraa_uart_ow_context)>();

  /// Destroy a mraa_uart_ow_context
  ///
  /// @param dev uart_ow context
  /// @return mraa_result_t
  int mraa_uart_ow_stop(mraa_uart_ow_context dev) {
    return _mraa_uart_ow_stop(dev);
  }

  late final _mraa_uart_ow_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_uart_ow_context)>>(
        'mraa_uart_ow_stop',
      );
  late final _mraa_uart_ow_stop =
      _mraa_uart_ow_stopPtr.asFunction<int Function(mraa_uart_ow_context)>();

  /// Read a byte from the 1-wire bus
  ///
  /// @param dev uart_ow context
  /// @return the byte read or -1 for error
  int mraa_uart_ow_read_byte(mraa_uart_ow_context dev) {
    return _mraa_uart_ow_read_byte(dev);
  }

  late final _mraa_uart_ow_read_bytePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_uart_ow_context)>>(
        'mraa_uart_ow_read_byte',
      );
  late final _mraa_uart_ow_read_byte =
      _mraa_uart_ow_read_bytePtr
          .asFunction<int Function(mraa_uart_ow_context)>();

  /// Write a byte to a 1-wire bus
  ///
  /// @param dev uart_ow context
  /// @param byte the byte to write to the bus
  /// @return the byte read back during the time slot or -1 for error
  int mraa_uart_ow_write_byte(mraa_uart_ow_context dev, int byte) {
    return _mraa_uart_ow_write_byte(dev, byte);
  }

  late final _mraa_uart_ow_write_bytePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(mraa_uart_ow_context, ffi.Uint8)>
  >('mraa_uart_ow_write_byte');
  late final _mraa_uart_ow_write_byte =
      _mraa_uart_ow_write_bytePtr
          .asFunction<int Function(mraa_uart_ow_context, int)>();

  /// Write a bit to a 1-wire bus and read a bit corresponding to the
  /// time slot back.  This is possible due to the way we wired the TX
  /// and RX together with a diode, forming a loopback.
  ///
  /// @param dev uart_ow context
  /// @param bit the bit to write to the bus
  /// @return the bit read back during the time slot or -1 for error
  int mraa_uart_ow_bit(mraa_uart_ow_context dev, int bit) {
    return _mraa_uart_ow_bit(dev, bit);
  }

  late final _mraa_uart_ow_bitPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(mraa_uart_ow_context, ffi.Uint8)>
  >('mraa_uart_ow_bit');
  late final _mraa_uart_ow_bit =
      _mraa_uart_ow_bitPtr
          .asFunction<int Function(mraa_uart_ow_context, int)>();

  /// Send a reset pulse to the 1-wire bus and test for device presence
  ///
  /// @param dev uart_ow context
  /// @return one of the mraa_result_t values
  int mraa_uart_ow_reset(mraa_uart_ow_context dev) {
    return _mraa_uart_ow_reset(dev);
  }

  late final _mraa_uart_ow_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_uart_ow_context)>>(
        'mraa_uart_ow_reset',
      );
  late final _mraa_uart_ow_reset =
      _mraa_uart_ow_resetPtr.asFunction<int Function(mraa_uart_ow_context)>();

  /// Begin a rom code search of the 1-wire bus.  This function
  /// implements the 1-wire search algorithm.  See the uart_ow.c example
  /// for an idea on how to use this function to identify all devices
  /// present on the bus.
  ///
  /// @param dev uart_ow context
  /// @param start true to start a new search from scratch, false to
  /// continue an existing search
  /// @param id the 8-byte rom code id of the current matched device when
  /// a device is found
  /// @return one of the mraa_result_t values
  int mraa_uart_ow_rom_search(
    mraa_uart_ow_context dev,
    int start,
    ffi.Pointer<ffi.Uint8> id,
  ) {
    return _mraa_uart_ow_rom_search(dev, start, id);
  }

  late final _mraa_uart_ow_rom_searchPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(
        mraa_uart_ow_context,
        mraa_boolean_t,
        ffi.Pointer<ffi.Uint8>,
      )
    >
  >('mraa_uart_ow_rom_search');
  late final _mraa_uart_ow_rom_search =
      _mraa_uart_ow_rom_searchPtr
          .asFunction<
            int Function(mraa_uart_ow_context, int, ffi.Pointer<ffi.Uint8>)
          >();

  /// Send a command byte to a device on the 1-wire bus
  ///
  /// @param dev uart_ow context
  /// @param command the command byte to send
  /// @param id the rom code id of the device to receive the command,
  /// NULL for all devices on the bus
  /// @return one of the mraa_result_t values
  int mraa_uart_ow_command(
    mraa_uart_ow_context dev,
    int command,
    ffi.Pointer<ffi.Uint8> id,
  ) {
    return _mraa_uart_ow_command(dev, command, id);
  }

  late final _mraa_uart_ow_commandPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(
        mraa_uart_ow_context,
        ffi.Uint8,
        ffi.Pointer<ffi.Uint8>,
      )
    >
  >('mraa_uart_ow_command');
  late final _mraa_uart_ow_command =
      _mraa_uart_ow_commandPtr
          .asFunction<
            int Function(mraa_uart_ow_context, int, ffi.Pointer<ffi.Uint8>)
          >();

  /// Perform a Dallas 1-wire compliant CRC8 computation on a buffer
  ///
  /// @param buffer the buffer containing the data
  /// @param length the length of the buffer
  /// @return the computed CRC
  int mraa_uart_ow_crc8(ffi.Pointer<ffi.Uint8> buffer, int length) {
    return _mraa_uart_ow_crc8(buffer, length);
  }

  late final _mraa_uart_ow_crc8Ptr = _lookup<
    ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Uint8>, ffi.Uint16)>
  >('mraa_uart_ow_crc8');
  late final _mraa_uart_ow_crc8 =
      _mraa_uart_ow_crc8Ptr
          .asFunction<int Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Initialise led_context, based on led index.
  ///
  /// @param led ID of the LED
  /// @returns LED context or NULL
  mraa_led_context mraa_led_init(int led) {
    return _mraa_led_init(led);
  }

  late final _mraa_led_initPtr =
      _lookup<ffi.NativeFunction<mraa_led_context Function(ffi.Int)>>(
        'mraa_led_init',
      );
  late final _mraa_led_init =
      _mraa_led_initPtr.asFunction<mraa_led_context Function(int)>();

  /// Initialise led_context, based on led function name.
  /// The structure of LED entry in sysfs is "devicename:colour:function"
  /// This api expects only one unique LED identifier which would be
  /// "function" name most often. For instance, `mraa_led_init_raw("user4");`
  ///
  /// @param led_dev Name of the LED device
  /// @returns LED context or NULL
  mraa_led_context mraa_led_init_raw(ffi.Pointer<ffi.Char> led_dev) {
    return _mraa_led_init_raw(led_dev);
  }

  late final _mraa_led_init_rawPtr = _lookup<
    ffi.NativeFunction<mraa_led_context Function(ffi.Pointer<ffi.Char>)>
  >('mraa_led_init_raw');
  late final _mraa_led_init_raw =
      _mraa_led_init_rawPtr
          .asFunction<mraa_led_context Function(ffi.Pointer<ffi.Char>)>();

  /// Set LED brightness
  ///
  /// @param dev LED context
  /// @param value Integer value to write
  /// @returns Result of operation
  int mraa_led_set_brightness(mraa_led_context dev, int value) {
    return _mraa_led_set_brightness(dev, value);
  }

  late final _mraa_led_set_brightnessPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(mraa_led_context, ffi.Int)>
  >('mraa_led_set_brightness');
  late final _mraa_led_set_brightness =
      _mraa_led_set_brightnessPtr
          .asFunction<int Function(mraa_led_context, int)>();

  /// Read LED brightness
  ///
  /// @param dev LED context
  /// @returns Brightness value
  int mraa_led_read_brightness(mraa_led_context dev) {
    return _mraa_led_read_brightness(dev);
  }

  late final _mraa_led_read_brightnessPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_led_context)>>(
        'mraa_led_read_brightness',
      );
  late final _mraa_led_read_brightness =
      _mraa_led_read_brightnessPtr.asFunction<int Function(mraa_led_context)>();

  /// Read LED maximum brightness
  ///
  /// @param dev LED context
  /// @returns Maximum brightness value
  int mraa_led_read_max_brightness(mraa_led_context dev) {
    return _mraa_led_read_max_brightness(dev);
  }

  late final _mraa_led_read_max_brightnessPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(mraa_led_context)>>(
        'mraa_led_read_max_brightness',
      );
  late final _mraa_led_read_max_brightness =
      _mraa_led_read_max_brightnessPtr
          .asFunction<int Function(mraa_led_context)>();

  /// Set LED trigger
  ///
  /// @param dev LED context
  /// @param trigger Type of trigger to set
  /// @returns Result of operation
  int mraa_led_set_trigger(
    mraa_led_context dev,
    ffi.Pointer<ffi.Char> trigger,
  ) {
    return _mraa_led_set_trigger(dev, trigger);
  }

  late final _mraa_led_set_triggerPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int32 Function(mraa_led_context, ffi.Pointer<ffi.Char>)
    >
  >('mraa_led_set_trigger');
  late final _mraa_led_set_trigger =
      _mraa_led_set_triggerPtr
          .asFunction<int Function(mraa_led_context, ffi.Pointer<ffi.Char>)>();

  /// Clear active LED trigger
  ///
  /// @param dev LED context
  /// @returns Result of operation
  int mraa_led_clear_trigger(mraa_led_context dev) {
    return _mraa_led_clear_trigger(dev);
  }

  late final _mraa_led_clear_triggerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_led_context)>>(
        'mraa_led_clear_trigger',
      );
  late final _mraa_led_clear_trigger =
      _mraa_led_clear_triggerPtr.asFunction<int Function(mraa_led_context)>();

  /// Close LED file descriptors and free the context memory
  ///
  /// @param dev LED context
  /// @returns Result of operation
  int mraa_led_close(mraa_led_context dev) {
    return _mraa_led_close(dev);
  }

  late final _mraa_led_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(mraa_led_context)>>(
        'mraa_led_close',
      );
  late final _mraa_led_close =
      _mraa_led_closePtr.asFunction<int Function(mraa_led_context)>();
}

/// MRAA supported platform types
abstract class mraa_platform_t {
  /// < The Generation 1 Galileo platform (RevD)
  static const int MRAA_INTEL_GALILEO_GEN1 = 0;

  /// < The Generation 2 Galileo platform (RevG/H)
  static const int MRAA_INTEL_GALILEO_GEN2 = 1;

  /// < The Intel Edison (FAB C)
  static const int MRAA_INTEL_EDISON_FAB_C = 2;

  /// < The Intel DE3815 Baytrail NUC
  static const int MRAA_INTEL_DE3815 = 3;

  /// < The Intel Minnow Board Max
  static const int MRAA_INTEL_MINNOWBOARD_MAX = 4;

  /// < The different Raspberry PI Models -like  A,B,A+,B+
  static const int MRAA_RASPBERRY_PI = 5;

  /// < The different BeagleBone Black Modes B/C
  static const int MRAA_BEAGLEBONE = 6;

  /// < Allwinner A20 based Banana Pi and Banana Pro
  static const int MRAA_BANANA = 7;

  /// < The Intel 5th generations Broadwell NUCs
  static const int MRAA_INTEL_NUC5 = 8;

  /// < Linaro 96boards
  static const int MRAA_96BOARDS = 9;

  /// < The Intel SoFIA 3GR
  static const int MRAA_INTEL_SOFIA_3GR = 10;

  /// < The Intel Braswell Cherryhills
  static const int MRAA_INTEL_CHERRYHILLS = 11;

  /// < The UP Board
  static const int MRAA_UP = 12;

  /// < The Intel Joule Expansion Board
  static const int MRAA_INTEL_JOULE_EXPANSION = 13;
  static const int MRAA_INTEL_GT_TUCHUCK = 13;

  /// < The phyBOARD-Wega
  static const int MRAA_PHYBOARD_WEGA = 14;

  /// < Terasic DE-Nano-SoC Board
  static const int MRAA_DE_NANO_SOC = 15;

  /// < The UP^2 Board
  static const int MRAA_UP2 = 16;

  /// < Mediatek MT7688 based Linkit boards
  static const int MRAA_MTK_LINKIT = 17;

  /// < MT7688 based Onion Omega2 board
  static const int MRAA_MTK_OMEGA2 = 18;

  /// < IEI Tank System
  static const int MRAA_IEI_TANK = 19;

  /// < Radxa ROCK PI 4 Models A/B/C
  static const int MRAA_ROCKPI4 = 20;

  /// < Adlink Industrial PI
  static const int MRAA_ADLINK_IPI = 21;

  /// < Adlink LEC-AL
  static const int MRAA_ADLINK_LEC_AL = 22;

  /// < Adlink LEC-AL
  static const int MRAA_ADLINK_LEC_AL_AI = 23;

  /// < The UPXTREME Board
  static const int MRAA_UPXTREME = 24;

  /// < Intel Learning Kit
  static const int MRAA_INTEL_ILK = 25;

  /// < Siemens IOT2050 board
  static const int MRAA_SIEMENS_IOT2050 = 26;

  /// < FTDI FT4222 USB to i2c bridge
  static const int MRAA_FTDI_FT4222 = 256;

  /// < GrovePi shield i2c bridge
  static const int MRAA_GROVEPI = 1024;

  /// < Firmata uart platform/bridge
  static const int MRAA_GENERIC_FIRMATA = 1280;

  /// < Android Things peripheral manager platform
  static const int MRAA_ANDROID_PERIPHERALMANAGER = 95;

  /// < Mock platform, which requires no real hardware
  static const int MRAA_MOCK_PLATFORM = 96;

  /// < User initialised platform from json
  static const int MRAA_JSON_PLATFORM = 97;

  /// < Platform with no capabilities that hosts a sub platform
  static const int MRAA_NULL_PLATFORM = 98;

  /// < An unknown platform type, typically will load INTEL_GALILEO_GEN1
  static const int MRAA_UNKNOWN_PLATFORM = 99;
}

/// Intel edison miniboard numbering enum
abstract class mraa_intel_edison_miniboard_t {
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_1 = 0;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_5 = 4;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_7 = 6;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_8 = 7;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_9 = 8;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_10 = 9;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_11 = 10;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_12 = 11;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J17_14 = 13;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_1 = 14;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_2 = 15;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_6 = 19;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_7 = 20;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_8 = 21;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_10 = 23;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_11 = 24;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_12 = 25;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J18_13 = 26;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_4 = 31;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_5 = 32;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_6 = 33;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_8 = 35;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_9 = 36;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_10 = 37;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_11 = 38;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_12 = 39;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_13 = 40;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J19_14 = 41;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_3 = 44;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_4 = 45;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_5 = 46;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_6 = 47;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_7 = 48;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_8 = 49;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_9 = 50;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_10 = 51;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_11 = 52;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_12 = 53;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_13 = 54;
  static const int MRAA_INTEL_EDISON_MINIBOARD_J20_14 = 55;
}

/// Intel Edison raw GPIO numbering enum
abstract class mraa_intel_edison_t {
  static const int MRAA_INTEL_EDISON_GP182 = 0;
  static const int MRAA_INTEL_EDISON_GP135 = 4;
  static const int MRAA_INTEL_EDISON_GP27 = 6;
  static const int MRAA_INTEL_EDISON_GP20 = 7;
  static const int MRAA_INTEL_EDISON_GP28 = 8;
  static const int MRAA_INTEL_EDISON_GP111 = 0;
  static const int MRAA_INTEL_EDISON_GP109 = 10;
  static const int MRAA_INTEL_EDISON_GP115 = 11;
  static const int MRAA_INTEL_EDISON_GP128 = 13;
  static const int MRAA_INTEL_EDISON_GP13 = 14;
  static const int MRAA_INTEL_EDISON_GP165 = 15;
  static const int MRAA_INTEL_EDISON_GP19 = 19;
  static const int MRAA_INTEL_EDISON_GP12 = 20;
  static const int MRAA_INTEL_EDISON_GP183 = 21;
  static const int MRAA_INTEL_EDISON_GP110 = 23;
  static const int MRAA_INTEL_EDISON_GP114 = 24;
  static const int MRAA_INTEL_EDISON_GP129 = 25;
  static const int MRAA_INTEL_EDISON_GP130 = 26;
  static const int MRAA_INTEL_EDISON_GP44 = 31;
  static const int MRAA_INTEL_EDISON_GP46 = 32;
  static const int MRAA_INTEL_EDISON_GP48 = 33;
  static const int MRAA_INTEL_EDISON_GP131 = 35;
  static const int MRAA_INTEL_EDISON_GP14 = 36;
  static const int MRAA_INTEL_EDISON_GP40 = 37;
  static const int MRAA_INTEL_EDISON_GP43 = 38;
  static const int MRAA_INTEL_EDISON_GP77 = 39;
  static const int MRAA_INTEL_EDISON_GP82 = 40;
  static const int MRAA_INTEL_EDISON_GP83 = 41;
  static const int MRAA_INTEL_EDISON_GP134 = 44;
  static const int MRAA_INTEL_EDISON_GP45 = 45;
  static const int MRAA_INTEL_EDISON_GP47 = 46;
  static const int MRAA_INTEL_EDISON_GP49 = 47;
  static const int MRAA_INTEL_EDISON_GP15 = 48;
  static const int MRAA_INTEL_EDISON_GP84 = 49;
  static const int MRAA_INTEL_EDISON_GP42 = 50;
  static const int MRAA_INTEL_EDISON_GP41 = 51;
  static const int MRAA_INTEL_EDISON_GP78 = 52;
  static const int MRAA_INTEL_EDISON_GP79 = 53;
  static const int MRAA_INTEL_EDISON_GP80 = 54;
  static const int MRAA_INTEL_EDISON_GP81 = 55;
}

/// Raspberry PI Wiring compatible numbering enum
abstract class mraa_raspberry_wiring_t {
  static const int MRAA_RASPBERRY_WIRING_PIN8 = 3;
  static const int MRAA_RASPBERRY_WIRING_PIN9 = 5;
  static const int MRAA_RASPBERRY_WIRING_PIN7 = 7;
  static const int MRAA_RASPBERRY_WIRING_PIN15 = 8;
  static const int MRAA_RASPBERRY_WIRING_PIN16 = 10;
  static const int MRAA_RASPBERRY_WIRING_PIN0 = 11;
  static const int MRAA_RASPBERRY_WIRING_PIN1 = 12;
  static const int MRAA_RASPBERRY_WIRING_PIN2 = 13;
  static const int MRAA_RASPBERRY_WIRING_PIN3 = 15;
  static const int MRAA_RASPBERRY_WIRING_PIN4 = 16;
  static const int MRAA_RASPBERRY_WIRING_PIN5 = 18;
  static const int MRAA_RASPBERRY_WIRING_PIN12 = 19;
  static const int MRAA_RASPBERRY_WIRING_PIN13 = 21;
  static const int MRAA_RASPBERRY_WIRING_PIN6 = 22;
  static const int MRAA_RASPBERRY_WIRING_PIN14 = 23;
  static const int MRAA_RASPBERRY_WIRING_PIN10 = 24;
  static const int MRAA_RASPBERRY_WIRING_PIN11 = 26;
  static const int MRAA_RASPBERRY_WIRING_PIN17 = 29;
  static const int MRAA_RASPBERRY_WIRING_PIN21 = 29;
  static const int MRAA_RASPBERRY_WIRING_PIN18 = 30;
  static const int MRAA_RASPBERRY_WIRING_PIN19 = 31;
  static const int MRAA_RASPBERRY_WIRING_PIN22 = 31;
  static const int MRAA_RASPBERRY_WIRING_PIN20 = 32;
  static const int MRAA_RASPBERRY_WIRING_PIN26 = 32;
  static const int MRAA_RASPBERRY_WIRING_PIN23 = 33;
  static const int MRAA_RASPBERRY_WIRING_PIN24 = 35;
  static const int MRAA_RASPBERRY_WIRING_PIN27 = 36;
  static const int MRAA_RASPBERRY_WIRING_PIN25 = 37;
  static const int MRAA_RASPBERRY_WIRING_PIN28 = 38;
  static const int MRAA_RASPBERRY_WIRING_PIN29 = 40;
}

/// MRAA return codes
abstract class mraa_result_t {
  /// < Expected response
  static const int MRAA_SUCCESS = 0;

  /// < Feature TODO
  static const int MRAA_ERROR_FEATURE_NOT_IMPLEMENTED = 1;

  /// < Feature not supported by HW
  static const int MRAA_ERROR_FEATURE_NOT_SUPPORTED = 2;

  /// < Verbosity level wrong
  static const int MRAA_ERROR_INVALID_VERBOSITY_LEVEL = 3;

  /// < Parameter invalid
  static const int MRAA_ERROR_INVALID_PARAMETER = 4;

  /// < Handle invalid
  static const int MRAA_ERROR_INVALID_HANDLE = 5;

  /// < No resource of that type avail
  static const int MRAA_ERROR_NO_RESOURCES = 6;

  /// < Resource invalid
  static const int MRAA_ERROR_INVALID_RESOURCE = 7;

  /// < Queue type incorrect
  static const int MRAA_ERROR_INVALID_QUEUE_TYPE = 8;

  /// < No data available
  static const int MRAA_ERROR_NO_DATA_AVAILABLE = 9;

  /// < Platform not recognised
  static const int MRAA_ERROR_INVALID_PLATFORM = 10;

  /// < Board information not initialised
  static const int MRAA_ERROR_PLATFORM_NOT_INITIALISED = 11;

  /// < UART OW Short Circuit Detected
  static const int MRAA_ERROR_UART_OW_SHORTED = 12;

  /// < UART OW No devices detected
  static const int MRAA_ERROR_UART_OW_NO_DEVICES = 13;

  /// < UART OW Data/Bus error detected
  static const int MRAA_ERROR_UART_OW_DATA_ERROR = 14;

  /// < Unknown Error
  static const int MRAA_ERROR_UNSPECIFIED = 99;
}

/// Enum representing different possible modes for a pin.
abstract class mraa_pinmodes_t {
  /// < Pin Valid
  static const int MRAA_PIN_VALID = 0;

  /// < General Purpose IO
  static const int MRAA_PIN_GPIO = 1;

  /// < Pulse Width Modulation
  static const int MRAA_PIN_PWM = 2;

  /// < Faster GPIO
  static const int MRAA_PIN_FAST_GPIO = 3;

  /// < SPI
  static const int MRAA_PIN_SPI = 4;

  /// < I2C
  static const int MRAA_PIN_I2C = 5;

  /// < Analog in
  static const int MRAA_PIN_AIO = 6;

  /// < UART
  static const int MRAA_PIN_UART = 7;
}

/// Enum reprensenting different i2c speeds/modes
abstract class mraa_i2c_mode_t {
  /// < up to 100Khz
  static const int MRAA_I2C_STD = 0;

  /// < up to 400Khz
  static const int MRAA_I2C_FAST = 1;

  /// < up to 3.4Mhz
  static const int MRAA_I2C_HIGH = 2;
}

/// Enum representing different uart parity states
abstract class mraa_uart_parity_t {
  static const int MRAA_UART_PARITY_NONE = 0;
  static const int MRAA_UART_PARITY_EVEN = 1;
  static const int MRAA_UART_PARITY_ODD = 2;
  static const int MRAA_UART_PARITY_MARK = 3;
  static const int MRAA_UART_PARITY_SPACE = 4;
}

/// MRAA boolean type
/// 1 For TRUE
typedef mraa_boolean_t = ffi.UnsignedInt;

final class _pwm extends ffi.Opaque {}

/// Mraa Pwm Context
typedef mraa_pwm_context = ffi.Pointer<_pwm>;

final class _gpio extends ffi.Opaque {}

/// Gpio Output modes
abstract class mraa_gpio_mode_t {
  /// < Default. Strong high and low
  static const int MRAA_GPIO_STRONG = 0;

  /// < Resistive High
  static const int MRAA_GPIO_PULLUP = 1;

  /// < Resistive Low
  static const int MRAA_GPIO_PULLDOWN = 2;

  /// < High Z State
  static const int MRAA_GPIO_HIZ = 3;
  static const int MRAA_GPIOD_ACTIVE_LOW = 4;
  static const int MRAA_GPIOD_OPEN_DRAIN = 5;
  static const int MRAA_GPIOD_OPEN_SOURCE = 6;
}

/// Gpio Direction options
abstract class mraa_gpio_dir_t {
  /// < Output. A Mode can also be set
  static const int MRAA_GPIO_OUT = 0;

  /// < Input
  static const int MRAA_GPIO_IN = 1;

  /// < Output. Init High
  static const int MRAA_GPIO_OUT_HIGH = 2;

  /// < Output. Init Low
  static const int MRAA_GPIO_OUT_LOW = 3;
}

/// Gpio Edge types for interrupts
abstract class mraa_gpio_edge_t {
  /// < No interrupt on Gpio
  static const int MRAA_GPIO_EDGE_NONE = 0;

  /// < Interrupt on rising & falling
  static const int MRAA_GPIO_EDGE_BOTH = 1;

  /// < Interrupt on rising only
  static const int MRAA_GPIO_EDGE_RISING = 2;

  /// < Interrupt on falling only
  static const int MRAA_GPIO_EDGE_FALLING = 3;
}

/// Gpio input modes
abstract class mraa_gpio_input_mode_t {
  /// < Resistive High
  static const int MRAA_GPIO_ACTIVE_HIGH = 0;

  /// < Resistive Low
  static const int MRAA_GPIO_ACTIVE_LOW = 1;
}

/// Gpio output driver modes
abstract class mraa_gpio_out_driver_mode_t {
  /// < Open Drain Configuration
  static const int MRAA_GPIO_OPEN_DRAIN = 0;

  /// < Push Pull Configuration
  static const int MRAA_GPIO_PUSH_PULL = 1;
}

/// Gpio event object
final class mraa_gpio_event extends ffi.Struct {
  /// < id of event
  @ffi.Int()
  external int id;

  /// < timestamp
  @mraa_timestamp_t()
  external int timestamp;
}

typedef mraa_timestamp_t = ffi.UnsignedLongLong;

/// Opaque pointer definition to the internal struct _gpio
typedef mraa_gpio_context = ffi.Pointer<_gpio>;
typedef mraa_gpio_events_t = ffi.Pointer<mraa_gpio_event>;

final class _aio extends ffi.Opaque {}

/// Opaque pointer definition to the internal struct _aio. This context refers
/// to one single AIO pin on the board.
typedef mraa_aio_context = ffi.Pointer<_aio>;

/// MRAA SPI Modes
abstract class mraa_spi_mode_t {
  /// < CPOL = 0, CPHA = 0, Clock idle low, data is clocked in on rising edge,
  /// output data (change) on falling edge
  static const int MRAA_SPI_MODE0 = 0;

  /// < CPOL = 0, CPHA = 1, Clock idle low, data is clocked in on falling edge,
  /// output data (change) on rising edge
  static const int MRAA_SPI_MODE1 = 1;

  /// < CPOL = 1, CPHA = 0, Clock idle low, data is clocked in on falling edge,
  /// output data (change) on rising edge
  static const int MRAA_SPI_MODE2 = 2;

  /// < CPOL = 1, CPHA = 1, Clock idle low, data is clocked in on rising, edge
  /// output data (change) on falling edge
  static const int MRAA_SPI_MODE3 = 3;
}

final class _spi extends ffi.Opaque {}

/// Opaque pointer definition to the internal struct _spi
typedef mraa_spi_context = ffi.Pointer<_spi>;

final class _i2c extends ffi.Opaque {}

/// Opaque pointer definition to the internal struct _i2c
typedef mraa_i2c_context = ffi.Pointer<_i2c>;

final class _uart extends ffi.Opaque {}

/// Mraa Uart Context
typedef mraa_uart_context = ffi.Pointer<_uart>;

/// for now, we simply use the normal MRAA UART context
final class _mraa_uart_ow extends ffi.Struct {
  /// Uart Context
  external mraa_uart_context uart;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedChar> ROM_NO;

  /// Context laxt discrepancy
  @ffi.Int()
  external int LastDiscrepancy;

  /// Context las family discrepancy
  @ffi.Int()
  external int LastFamilyDiscrepancy;

  /// Context las device flag
  @mraa_boolean_t()
  external int LastDeviceFlag;
}

/// UART One Wire ROM related Command bytes
abstract class mraa_uart_ow_rom_cmd_t {
  /// < read rom, when only one device on bus
  static const int MRAA_UART_OW_CMD_READ_ROM = 51;

  /// < match a specific rom code
  static const int MRAA_UART_OW_CMD_MATCH_ROM = 85;

  /// < skip match/search rom
  static const int MRAA_UART_OW_CMD_SKIP_ROM = 204;

  /// < search all roms in alarm state
  static const int MRAA_UART_OW_CMD_SEARCH_ROM_ALARM = 236;

  /// < search all rom codes
  static const int MRAA_UART_OW_CMD_SEARCH_ROM = 240;
}

/// for now, we simply use the normal MRAA UART context
typedef mraa_uart_ow_context = ffi.Pointer<_mraa_uart_ow>;

final class _led extends ffi.Opaque {}

/// Opaque pointer definition to the internal struct _led
typedef mraa_led_context = ffi.Pointer<_led>;

const int MRAA_PLATFORM_NAME_MAX_SIZE = 64;

const int MRAA_PIN_NAME_SIZE = 12;

const int MRAA_SUB_PLATFORM_BIT_SHIFT = 9;

const int MRAA_SUB_PLATFORM_MASK = 512;

const int MRAA_MAIN_PLATFORM_OFFSET = 0;

const int MRAA_SUB_PLATFORM_OFFSET = 1;

const int MRAA_UART_OW_ROMCODE_SIZE = 8;
